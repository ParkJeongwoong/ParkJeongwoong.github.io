{"pageProps":{"markdown_gitHub":"# [CleanCode] 오류 처리\r\n\r\n```\r\n출처 : Clean Code - Robert C. Martin\r\n```\r\n\r\n에러를 처리할 때도 깨끗한 코드는 중요합니다.\r\n정리되지 않은 에러 처리 코드는 코드가 어떤 일을 하는지 파악하기 어렵게 만듭니다.\r\n\r\n오늘은 비즈니스 논리가 흐려지지 않도록 깨끗한 오류 처리 방법을 알아보겠습니다.\r\n\r\n\r\n\r\n## 예외 사용\r\n\r\n> 에러가 아니라 예외 사용하기\r\n\r\n많이들 사용하는 `try-catch`를 통한 예외처리를 사용하는 것은 코드를 깔끔하게 만듭니다.\r\n\r\n클린코드에서는 `에러코드`를 반환하는 방법 대신 `예외처리`를 할 것을 권장합니다.\r\n\r\n에러는 바로 확인해야 하기 때문에 **호출 코드가 복잡해지고** 개발을 하다보면 **오류 확인을 잊어버리기 쉽기 때문**입니다.\r\n\r\n```java\r\n // 동작\r\nHandler handler = exampleMethod1();\r\n// 에러 확인\r\nif (handler != Handler.INVALID) {\r\n\t// 동작\r\n\tRecorder recorder = exampleMethod2();\r\n\t// 에러 확인\r\n\tif (recorder.getStatus() != SUSPENDED) {\r\n\t\t<<nextStep...>>\r\n\t} else {\r\n\t\t<<errorHandling...>>\r\n\t}\r\n} else {\r\n\t<<errorHandling...>>\r\n}\r\n```\r\n\r\n무엇보다도 이렇게 조건문을 사용해서 에러를 확인하는 일은 **코드를 지저분하게 만듭니다.**\r\n\r\n반면 `try-catch`를 이용해 정상 동작과 예외 동작을 구분하는 것은 시각적으로 정리된 느낌을 주고 비즈니스 로직이 무엇인지 파악하기 쉽게 만듭니다.\r\n\r\n```java\r\ntry {\r\n\t<<businessLogic...>>\r\n}\r\ncatch {\r\n\t<<errorHandling...>>\r\n}\r\n```\r\n\r\n\r\n\r\n## Try-Catch-Finally\r\n\r\n> 항상 try-catch-finally문부터 작성\r\n\r\nTDD를 사용해,\r\n\r\n1. 예외를 일으키는 테스트 케이스 작성\r\n2. try-catch 구조의 코드 작성\r\n3. 예외를 세분화\r\n\r\n하는 식으로 코드를 작성하는 방법이 권장됩니다.\r\n\r\n1. 단위 테스트와 베이스 코드\r\n\r\n```java\r\n@Test(expected = StorageException.class)\r\npublic void retrieveSectionShouldThrowOnInvalidFileName() {\r\n\tsectionStore.retrieveSection(\"invalid - file\");\r\n}\r\n```\r\n\r\n```java\r\npublic List<RecordedGrip> retrieveSection(String sectionName) {\r\n\t// 실제로 구현할 때까지 비어 있는 더미를 반환\r\n\treturn new ArrayList<RecordedGrip>();\r\n}\r\n```\r\n\r\n2. try-catch 구조\r\n\r\n```java\r\npublic List<RecordedGrip> retrieveSection(String sectionName) {\r\n\ttry {\r\n\t\tFileInputStream stream = new FileInputStream(sectionName);\r\n\t} catch (Exception e) {\r\n\t\tthrow new StorageException(\"retrieval error\", e);\r\n\t}\r\n\treturn new ArrayList<RecordedGrip>();\r\n}\r\n```\r\n\r\n3. 예외 세분화\r\n\r\n```java\r\npublic List<RecordedGrip> retrieveSection(String sectionName) {\r\n  try{\r\n    FileInputStream stream = new FileInputStream(sectionName);\r\n    stream.close();\r\n  } catch (FileNotFoundException e) {\r\n    throw new StorageException(\"retrieval error\", e);\r\n  }\r\n  return new ArrayList<RecordedGrip>();\r\n}\r\n```\r\n\r\n\r\n\r\n## Unchecked Exception 사용\r\n\r\n> Checked Exception 대신 Unchecked Exception 사용\r\n\r\n\r\n||Checked EXception|Unchecked Exception|\r\n|---|:---:|:---:|\r\n|확인 시점|컴파일|런타임|\r\n|처리 여부|`반드시 처리해야 함`|`꼭 처리하지 않아도 됨`|\r\n|트랜잭션 처리|No Rollback|Rollback|\r\n|예시|IOException, ClassNotFoundException|NullPointerException, ArithmeticException|\r\n\r\n\r\n**Checked Exception은 OCP(Open-Close Principle)를 위반**합니다.\r\n\r\nChecked Exceoption은 반드시 처리해야 하기 때문에, 만약 상위 계층으로 예외를 던져야 하는 상황이 생기면 Exception이 지나가는 매 계층마다 해당 예외를 정의해야 하는 문제가 생깁니다.\r\n(즉, 하위 단계에서 새로운 예외가 발생하면 연관된 상위 단계를 모두 수정해야 합니다.)\r\n\r\n```java\r\n// method2에서 NotPrintException을 던졌기 때문에 상위 계층인 method1에서도 해당 예외를 추가해야 합니다.\r\npublic void method1(boolean flag) throws NotPrintException {\r\n\tmethod2(flag);\r\n}\r\n\r\npublic void method2(boolean flag) throws NotPrintException {\r\n\tif (flag)\r\n\t\tSystem.out.println(\"Hi\");\r\n\telse\r\n\t\tthrow new NotPrintException();\r\n}\r\n```\r\n\r\n필요하다면 사용해야겠지만 가능하다면 예외는 Unchecked Exception을 사용하는 것이 좋습니다.\r\n\r\n\r\n\r\n## 예외에 의미 제공\r\n\r\n> 오류와 관련된 정보 담기\r\n\r\n예외에 의미를 담아 발생 원인과 위치를 파악하는데 도움을 줘야 합니다.\r\n\r\n\r\n\r\n## 깔끔하게 오류 잡아내기\r\n\r\n> 클래스를 활용하여 깔끔하게 오류 처리하기\r\n\r\n오류를 깔끔하게 잡아내는 건 무척 중요합니다.\r\n\r\n\r\n\r\n```java\r\nACMEPort port = new ACMEPort(12);\r\n\r\ntry {\r\n\tport.open();\r\n} catch (DeviceResponseException e) {\r\n\treportPortError(e);\r\n\tlogger.log(\"Device response exception\", e);\r\n} catch (ATM1212UnlockedException e) {\r\n\treportPortError(e);\r\n\tlogger.log(\"Unlock exception\", e);\r\n} catch (GMXError e) {\r\n\treportPortError(e);\r\n\tlogger.log(\"Device response exception\");\r\n} finally {\r\n\t...\r\n}\r\n```\r\n\r\n위의 코드는 분류도 제대로 되지 않았고 로그만 찍히는 예외 처리 코드입니다.\r\n\r\n```java\r\nLocalPort port = new LocalPort(12);\r\ntry {\r\n\tport.open();\r\n} catch (PortDeviceFilure e) {\r\n\treportError(e);\r\n\tlogger.log(e.getMessage( ), e);\r\n} finally {\r\n\t...\r\n}\r\n```\r\n\r\n```java\r\n// LocalPort 클래스 (Wrapper Class)\r\npublic class LocalPort {\r\n\tprivate ACMEPort innerPort;\r\n\tpublic LocalPort(int portNumber) {\r\n\t\tinnerPort = new ACMEPort(portNumber);\r\n\t}\r\n\t\r\n\tpublic void open( ) {\r\n\t\ttry {\r\n\t\t\tinnerPort.open();\r\n\t\t} catch (DeviceResponseException e) {\r\n\t\t\tthrow new PortDeviceFailure(e);\r\n\t\t} catch (ATM1212UnlockedException e) {\r\n\t\t\tthrow new PortDeviceFailure(e);\r\n\t\t} catch (GMXError e) {\r\n\t\t\tthrow new PortDeviceFailure(e);\r\n\t\t} \r\n\t}\r\n\t...\r\n}\r\n```\r\n\r\nACMEPort 클래스를 감싸는 Wrapper 클래스(LocalPort 클래스)를 이용해서 port open 중 발생하는 여러 에러를 `PortDeviceFilure` 하나로 처리했습니다.\r\n\r\n외부 API를 감싸면,\r\n1. 에러 처리가 간결해지고\r\n2. 외부 라이브러리와 프로그램 사이의 의존성이 줄어들고\r\n3. 테스트가 쉬워지고\r\n4. 외부 API의 설계 방식에 의존하지 않아도 됩니다.\r\n\r\n\r\n\r\n## 정상 흐름을 정의\r\n\r\n> 예외 처리가 비즈니스 로직을 해지치 않기\r\n\r\n깔끔한 예외 처리도 때로는 없는 게 나을 때가 있습니다.\r\n\r\n```java\r\ntry {\r\n\tMealExpenses expenses = expenseReportDAO.getMeals(employee.getID());\r\n\tm_total += expenses.getTotal();\r\n} catch (MealExpensesNotFound e) {\r\n\tm_total += getMealPerDiem();\r\n}\r\n```\r\n\r\n청구될 식비, MealExpenses 객체가 없다면 Error를 발생시키면서 기본 식비를 더하는 코드입니다.\r\n이런 예외 처리는 논리를 흐리게 만듭니다.\r\n\r\n이럴 때는 애초에 이런 특수한 상황(에러 상황)을 만들지 않는 게 더 적합합니다.\r\n\r\n```java\r\nMealExpenses expenses = expenseReportDAO.getMeals(employee.getID());\r\nm_total += expenses.getTotal();\r\n```\r\n\r\nexpenseReportDAO.getMeals()가 항상 MealExpenses를 반환하게 하고 만약 식비가 없다면 기본 식비를 getTotal()에서 반환하도록 만들면 특수한 상황(에러 상황)이 생기지 않습니다.\r\n\r\n\r\n\r\n## null을 반환하거나 전달하지 않기\r\n\r\n> null 대신 예외나 특수 사례 객체 반환\r\n> \r\n> 이보다 최악은 인수로 null을 전달하는 것\r\n\r\n메서드의 입출력(인수&반환)에 null을 사용하는 건 null 확인을 매번 해야하는 리스크를 만듭니다.\r\n\r\n또 null 확인을 완벽하게 했다면 null 확인이 너무 많아 코드가 지저분해집니다.","documentTitle":"[CleanCode] 오류 처리","articleCategory":"Studied","articleId":"5"},"__N_SSG":true}