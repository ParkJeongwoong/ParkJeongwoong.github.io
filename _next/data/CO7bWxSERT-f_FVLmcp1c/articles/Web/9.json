{"pageProps":{"markdown":"# [Spring] Controller 객체\r\n\r\n오늘은 비즈니스 로직이 들어가 있는 Controller 객체에 대해 알아보겠습니다.\r\n\r\n\r\n\r\n## URL 매핑 - `@RequestMapping`\r\n\r\n사용자가 요청을 보내면 <u>(1) Dispatcher Servlet</u>이 <u>(2) HandlerMapping</u> 을 통해 적합한 Controller를 찾습니다. \r\n\r\nHandlerMapping의 방법엔 여러가지가 있는데 `@RequestMapping`은 그 중 하나인 **RequestMappingHandlerMapping** 방법에서 적합한 Controller 객체를 찾는 어노테이션입니다.\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/member\")\r\npublic class MemberController {\r\n\t...    \r\n}\r\n```\r\n\r\n\r\n\r\n@RequestMapping이 붙은 클래스 안에 @RequestMapping을 붙여 계층화를 이룰 수도 있습니다.\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/member\")\r\npublic class MemberController {\r\n    @RequestMapping(\"/memJoin\")\r\n    public String memJoin() {}\r\n}\r\n```\r\n\r\n\r\n\r\n## 요청 파라미터 처리\r\n\r\n사용자가 전달하는 HTTP 전송 정보를 Controller에서 사용하는 방법은 여러가지가 있습니다.\r\n\r\n\r\n\r\n예시)\r\n\r\n```html\r\n<input type=\"text\" name=\"memID\">\r\n<input type=\"password\" name=\"memPW\">\r\n```\r\n\r\n위과 같은 HTML 파일의 input 정보를 사용자가 전달한다고 가정하면 다음과 같은 방법으로 Controller에서 이를 활용할 수 있습니다.\r\n\r\n\r\n\r\n### 방법1) `HttpServletRequest`\r\n\r\n1. 먼저 **HttpServletRequest Class**를 이용해 <u>Request 정보 전체를 파라미터로 받습니다.</u>\r\n\r\n```java\r\n@RequestMapping(value=\"/memLogin\", method=RequestMethod.POST)\r\npublic String memLogin(Model model, HttpServletRequest request) {\r\n    ...\r\n}\r\n```\r\n\r\n2. 그리고 HttpServletRequest 클래스로 받은 파라미터 객체에서 <u>Getter를 이용해 개별 정보를 출력합니다.</u>\r\n\r\n```java\r\n@RequestMapping(value=\"/memLogin\", method=RequestMethod.POST)\r\npublic String memLogin(Model model, HttpServletRequest request) {\r\n    \r\n    String memID = request.getParameter(\"memID\");\r\n    String memPW = request.getParameter(\"memPW\");\r\n    \r\n}\r\n```\r\n\r\n\r\n\r\n### 방법2) `@RequestParam`\r\n\r\n1. 또 다른 방법은 **@RequestParam 어노테이션**을 객체에 붙여 <u>Request 정보를 개별적인 파라미터로 받는 것</u>이 있습니다.\r\n\r\n```java\r\n@RequestMapping(value=\"/memLogin\", method=RequestMethod.POST)\r\npublic String memLogin(Model model, @RequestParam(\"memID\") String memID, @RequestParam(\"memPW\") String memPW) {\r\n    ...\r\n}\r\n```\r\n\r\n이 경우 Getter를 이용하지 않지만 메소드의 파라미터 정의 부분이 길어져 보기 지저분하다는 단점이 있습니다.\r\n\r\n\r\n\r\n>  @RequestParam(..., **require=false**) : 값이 넘어오지 않아도 Exception 발생 X\r\n\r\n>  @RequestParam(..., **defaultValue=\"\"**) : 값이 넘어오지 않았을 때 들어가는 값\r\n\r\n\r\n\r\n### 방법3) `커맨드 객체` * 가장 많이 사용하는 방법\r\n\r\n마지막은 가장 많이 사용하는 방법인 커맨드 객체를 활용하는 방법입니다.\r\n\r\n1. 먼저 데이터를 받기 위한 <u>전용 Class</u>를 따로 만들어 줍니다.\r\n\r\n```java\r\npublic class Member {\r\n    \r\n    private String memID;\r\n    private String memPW;\r\n    \r\n    public String getMemID() {\r\n        return memID;\r\n    }\r\n    public void setMemID(String memID) {\r\n        this.memID = memID;\r\n    }\r\n    public String getMemPW() {\r\n        return memPW;\r\n    }\r\n    public void setMemID(String memPW) {\r\n        this.memPW = memPW;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n(ex. Member.java 안에 만든 Member 클래스)\r\n\r\n2. <u>Request 정보를 새롭게 만든 객체에 저장</u>, 이후 <u>Class 내 직접 만든 Getter를 이용해 Data를 출력합니다.</u>\r\n\r\n```java\r\n@RequestMapping(value=\"/memLogin\", method=RequestMethod.POST)\r\npublic String memLogin(Member member) {\r\n    ...\r\n}\r\n```\r\n\r\n(ex. MemberController.java)\r\n\r\n\r\n\r\n#### `@ModelAttribute`\r\n\r\n`@ModelAttribute` 어노테이션은 파라미터인 파라미터인 <u>커맨드 객체에</u> 붙어 **커맨드 객체의 이름**을 설정합니다.\r\n\r\n이후 **View(JSP)**에서 커맨드 객체를 참조할 때 변경된 이름을 통해 객체의 값을 불러올 수 있습니다.\r\n\r\n\r\n\r\n[@ModelAttribute 미사용]\r\n\r\n```java\r\npublic String test1(MyModel mym) {}\r\n```\r\n\r\n```jsp\r\n${mym.id}\r\n```\r\n\r\n- mym 객체를 View에서 불러올 때, mym 객체의 이름을 그대로 사용\r\n\r\n\r\n\r\n[@ModelAttribute 사용]\r\n\r\n```java\r\npublic String test2(@ModelAttribute(\"mymy\") MyModel mym) {}\r\n```\r\n\r\n```jsp\r\n${mymy.id}\r\n```\r\n\r\n- mymy라는 이름으로 mym 객체를 View에서 불러옴\r\n\r\n\r\n\r\n#### `@RequestBody`, `@RequestParam`\r\n\r\n- **@ModelAttribute** : HTTP 정보를 Model(객체)에 주입합니다.\r\n  - '생성자'나 'Setter'를 통해 주입 (만약 생성자나 Setter가 없으면 Mapping 되지 않습니다)\r\n  - HTTP Parameter의 타입 - 객체의 타입 검증 과정이 존재 (두 타입이 일치하지 않으면 BindException이 발생합니다)\r\n- **@RequestBody** : JSON 형태로 오는 HTTP Body의 정보를 Java의 객체로 변환시킵니다.\r\n- **@RequestParam** : <u>1개의 HTTP 요청 파라미터</u>를 받습니다.\r\n  - 기본적으로 **required=true**로 설정 (해당 파라미터가 없으면 400 Error를 반환합니다)\r\n\r\n\r\n\r\n## 데이터 타입\r\n\r\n> 커맨드 객체의 데이터 타입\r\n\r\n```html\r\n<input type=\"text\" name=\"memId\">\r\n<input type=\"password\" name=\"memPw\">\r\n<input type=\"text\" name=\"memAge\" size=\"4\" value=\"0\">\r\n```\r\n\r\n이런 input data를 받았을 때,\r\n\r\n```java\r\npublic class Member {\r\n    private String memId;\r\n    private String memPw;\r\n    private int memAge;\r\n}\r\n```\r\n\r\n당연하게도 커맨드 객체에서 원하는 데이터 타입으로 저장할 수 있습니다.\r\n\r\n\r\n\r\n만약 input data 여러 개를 하나의 변수에 저장해야 한다면 List 타입에 저장을 하면 됩니다.\r\n\r\n```html\r\nPHONE1 : \r\n<input type=\"text\" name=\"memPhones[0].memPhone1\" size=\"5\">\r\n<input type=\"text\" name=\"memPhones[0].memPhone2\" size=\"5\">\r\n<input type=\"text\" name=\"memPhones[0].memPhone3\" size=\"5\">\r\n\r\nPHONE2 : \r\n<input type=\"text\" name=\"memPhones[1].memPhone1\" size=\"5\">\r\n<input type=\"text\" name=\"memPhones[1].memPhone2\" size=\"5\">\r\n<input type=\"text\" name=\"memPhones[1].memPhone3\" size=\"5\">\r\n```\r\n\r\n```java\r\nprivate List<MemPhone> memPhones;\r\n```\r\n\r\n\r\n\r\n- **memPhone1** + **memPhone2** + **memPhone3** => `memPhone` 클래스\r\n- **memPhone** + **memPhone** => `List<memPhone> memPhones` ; memPhone이 모인 List, memPhones\r\n\r\n\r\n\r\n## Model & ModelAndView\r\n\r\n`Model`과 `ModelAndView` 모두 <u>View에 데이터를 전달</u>하기 위해 **Controller에서 사용되는 객체**입니다.\r\n\r\n차이 점은 `Model`은 **데이터만** 전달하지만, `ModelAndView`는 **데이터와 뷰의 이름**을 함께 전달한다는 것입니다.\r\n\r\n\r\n\r\n비교를 위한 코드입니다.\r\n\r\n(**memModifyOk.jsp**라는 View에서 **${memBef.memId}**, **${memAft.memId}**라는 이름으로 데이터를 사용하기 위한 `Model`과 `ModelAndView` 코드)\r\n\r\n```java\r\n// Model\r\n@RequestMapping(value = \"/memModify\", method = RequestMethod.POST)\r\npublic String memModify(Model model, Member member) {\r\n    Member[] members = service.memberModify(member);\r\n    \r\n    model.addAttribute(\"memBef\", members[0]);\r\n    model.addAttribute(\"memAft\", members[1]);\r\n    \r\n    return \"memModifyOk\";\r\n}\r\n```\r\n\r\n```java\r\n// ModelAndView\r\n@RequestMapping(value = \"/memModify\", method = RequestMethod.POST)\r\npublic ModelAndView memModify(Member member) {\r\n\tMember[] members = service.memberModify(member);\r\n    \r\n    ModelAndView mav = new ModelAndView();\r\n    mav.addObject(\"memBef\", members[0]);\r\n    mav.addObject(\"memAft\", members[1]);\r\n    \r\n    mav.setViewName(\"memModifyOk\");\r\n    \r\n    return mav;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 출처\r\n\r\n인프런 - 자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌\r\n\r\nhttp://wonwoo.ml/index.php/post/2308\r\n\r\nhttps://mangkyu.tistory.com/72\r\n","documentTitle":"[Spring] Controller 객체"},"__N_SSG":true}