{"pageProps":{"markdown_gitHub":"# [Spring Boot] 멀티 서버 스케쥴링, AOP\r\n\r\nBlue Green 무중단 배포를 사용한 뒤로 2개의 서버가 동시에 구동하게 되면서 @Scheduled 를 사용한 스케쥴 작업이 동시에 동작하는 문제가 생겼다. 크리티컬한 문제는 생기지 않았지만, 예약 데이터(Reservation)를 바탕으로 만드는 예약 관리 정보(AdminManageInfo)가 2개 씩 만들어지는  문제가 생겼다.\r\n\r\n이 문제를 해결하기 위한 여러 옵션을 조금 찾아봤다.\r\n\r\n- Redis를 이용한 기능 직접 구현\r\n\r\n- ShedLock : DB에 스케쥴 작업에 대한 정보를 저장하고 이를 통해 스케쥴을 관리하는 방식이다.\r\n- Quartz\r\n\r\n\r\n\r\n## 직접 구현\r\n\r\n1. 작업을 시작하기 전, Redis에서 작업 명을 key로 조회\r\n2. 캐시 정보가 있으면 skip\r\n3. 없으면 {작업 명과 서버 profile 명}을 {key, value}로 넣고 스케쥴 실행\r\n4. 작업을 완료하기 전 작업 명을 key로 다시 캐시 조회\r\n5. 캐시 정보가 없거나 서버 profile 명이 일치하지 않으면 rollback\r\n6. 일치하면 스케쥴 작업 완료\r\n\r\n이런 flow로 구현을 하려고 했다.\r\n\r\n그러려면 스케쥴 작업 앞 뒤로 (1) ~ (3) 작업과 (4) ~ (6) 작업을 공통으로 처리 해야 하므로 AOP를 활용하려고 생각했다.\r\n\r\n\r\n\r\n### ShedLock, Quartz\r\n\r\n다른 방법을 찾아보니 ShedLock과 Quartz를 사용하면 클러스터 환경에서 하나의 스케쥴만 실행할 수 있다는 걸 알았다.\r\n\r\nQuartz는 클러스터에 등록 노드들 중 하나를 Quartz가 골라서 수행시키는 방식이고\r\n\r\nShedLock은 내가 Redis로 구현하려고 했던 것처럼 DB를 이용해 스케쥴 실행 전 Lock을 걸고 수행하는 방식이었다.\r\n\r\n\r\n\r\n빠른 구현을 위해 우선 간단하게 Redis를 이용한 방식으로 구현하고, Quartz Job Scheduler를 사용하는 것으로 변경하기로 했다.\r\n\r\n\r\n\r\n## AOP\r\n\r\nRedis를 이용한 Schedule Lock을 구현하고 나서 이를 스케쥴 메서드에 공통적으로 적용하기 위해 AOP를 사용했다.\r\n\r\n\r\n\r\n다음은 AOP와 관련된 기본적인 개념이다.\r\n\r\n- Aspect : 정의된 모듈화된 관심사 (Advice + Point cut)\r\n- Advice : Aspect의 자세한 기능 구현\r\n- Advisor : Advice + Point cut 로 이뤄져 <u>Aspect를 구체적으로 언제 어떻게 적용할 결정</u>\r\n- Target : Advice의 대상\r\n- Joint Point : Advice 적용 위치 (Spring AOP는 프록시 패턴을 쓰므로 항상 메서드 실행 시)\r\n- Point cut : Joint Point 중 Advice가 적용되는 위치를 결정\r\n  - @Before : Joint Point 실행 전 동작\r\n  - @AfterReturning : 메서드의 정상 상황에서 동작 \r\n  - @AfterThrowing : 메서드의 예외 상황에서 동작\r\n  - @After : Joint Point 이후 정상, 예외 여부와 무관하게 동작\r\n  - @Around : 위 4가지 모두 포함 (모든 수정 가능)\r\n\r\n\r\n\r\n### 적용\r\n\r\n- 의존성을 추가한다\r\n\r\n  ```java\r\n  implementation('org.springframework.boot:spring-boot-starter-aop')\r\n  ```\r\n\r\n  - 이 의존성을 추가하면 **자동 프록시 생성기(AnnotationAwareAspectJAutoProxyCreator)** 가 스프링 어플리케이션 시작 시, @Aspect 빈을 읽고 Advisor를 생성한다.\r\n\r\n  - 이후 Advisor와 클래스, 메서드 정보를 매칭하면서 프록시를 적용할 대상 여부를 판단한다.\r\n  - 프록시 적용 대상이라면 프록시를 생성하고 이를 빈 저장소에 등록하고, 대상이 아니라면 그냥 빈을 저장소에 등록한다.\r\n\r\n- Aspect, Point cut 작성\r\n\r\n  - Around\r\n\r\n    ```java\r\n    @Slf4j\r\n    @Aspect\r\n    public class AspectV6Advice {\r\n    \r\n        @Around(\"execution(* com.yeoyeo.application.common..*(..))\")\r\n        public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable {\r\n            try {\r\n                // @Before\r\n                ...\r\n    \r\n                // Target 메서드 호출\r\n                Object result = joinPoint.proceed();\r\n    \r\n                // @AfterReturning\r\n                ...\r\n    \r\n                // 값 반환\r\n                return result;\r\n            } catch (Exception e) {\r\n                // @AfterThrowing\r\n                ...\r\n                throw e;\r\n            } finally {\r\n                //@ After\r\n                ...\r\n            }\r\n        }\r\n    }\r\n    ```\r\n\r\n  - Before\r\n\r\n    ```java\r\n    @Before(\"execution(* com.yeoyeo.application.common..*(..))\")\r\n    public void doBefore(JoinPoint joinPoint) {\r\n        log.info(\"[before] {}\", joinPoint.getSignature());\r\n    }\r\n    ```\r\n\r\n  - AfterReturning\r\n\r\n    ```java\r\n    @AfterReturning(value = \"execution(* com.yeoyeo.application.common..*(..))\", returning = \"result\")\r\n    public void doReturn(JoinPoint joinPoint, Object result) {\r\n        log.info(\"[return] {} return={}\", joinPoint.getSignature(), result);\r\n    }\r\n    ```\r\n\r\n  - AfterThrowing\r\n\r\n    ```java\r\n    @AfterThrowing(value = \"execution(* com.yeoyeo.application.common..*(..))\", throwing = \"ex\")\r\n    public void doThrowing(JoinPoint joinPoint, Exception ex) {\r\n        log.info(\"[ex] {} message={}\", joinPoint.getSignature(), ex.getMessage());\r\n    }\r\n    ```\r\n\r\n  - After\r\n\r\n    ```java\r\n    @After(value = \"execution(* com.yeoyeo.application.common..*(..))\")\r\n    public void doAfter(JoinPoint joinPoint) {\r\n        log.info(\"[after]\");\r\n    }\r\n    ```\r\n\r\n  - PointCut을 &&와 ||로 연결하여 사용 가능\r\n\r\n    ```java\r\n    @Slf4j\r\n    @Aspect\r\n    @Component\r\n    public class LoggingAspect {\r\n    \r\n        // Pointcut\r\n        @Pointcut(\"execution(* com.yeoyeo.adapter.controller..*.*(..))\")\r\n        private void controllerPointcut() {}\r\n        @Pointcut(\"execution(* com.yeoyeo.application..*Service.*(..))\")\r\n        private void servicePointcut() {}\r\n    \r\n    \r\n        // Aspect\r\n        @Before(\"controllerPointcut() || servicePointcut()\")\r\n        public void controllerServiceLogging(JoinPoint joinPoint) {\r\n            ...\r\n        }\r\n    \r\n    }\r\n    ```\r\n\r\n\r\n### PointCut\r\n\r\n- execution(접근제어자 반환타입* 선언타입 메서드이름* 예외)\r\n\r\n  - *이 쳐진 건 필수\r\n  - *를 사용하면 모든 타입 허용\r\n\r\n- @annotation\r\n\r\n  ```java\r\n  package com.yeoyeo.aop.annotation;\r\n  @Target(ElementType.METHOD)\r\n  @Retention(RetentionPolicy.RUNTIME)\r\n  public @interface MethodAop {\r\n      String value();\r\n  }\r\n  ```\r\n\r\n  ```java\r\n  @Around(\"@annotation(com.yeoyeo.aop.annotation.MethodAop)\")\r\n  public void aopAnnotation(ProceedingJoinPoint joinPoint) throws Throwable {\r\n      // 생략\r\n  }\r\n  ```\r\n\r\n  ","documentTitle":"[Spring Boot] 멀티 서버 스케쥴링, AOP","articleCategory":"Develop","articleId":"19"},"__N_SSG":true}