{"pageProps":{"markdown":"# [Spring] Connection Pool과 JDBC Template\r\n\r\nJDBC Interface는 편리한 도구이지만 몇 가지 불편한 점이 있습니다.\r\n\r\n하나는 같은 코드를 반복해서 쓴다는 것이고 다른 하나는 매번 드라이버를 로드해 데이터베이스와 연결시키고 Connection 객체를 생성한다는 것입니다.\r\n\r\n오늘은 이런 문제를 해결하는 방법인 Connection Pool과 JDBC Template을 소개하겠습니다.\r\n\r\n\r\n\r\n아래는 기존 JDBC Interface를 이용하여 DAO 클래스 안에 구현한 Insert 메소드 예시 코드입니다.\r\n\r\n```java\r\nprivate String driver = \"oracle.jdbc.driver.OracleDriver\";\r\nprivate String url = \"jdbc:oracle:thin:@localhost:1521:xe\";\r\nprivate String userid = \"scott\";\r\nprivate String userpw = \"tiger\";\r\n\r\nprivate Connection conn = null;\r\nprivate PreparedStatement pstmt = null;\r\nprivate ResultSet rs = null;\r\n\r\n@Override\r\npublic int memberInsert(Member member) {\r\n\t\r\n    int result = 0;\r\n\t\r\n    try {\r\n        Class.forName(driver);\r\n        conn = DriverManager.getConnection(url, userid, userpw);\r\n        // SQL 관련 부분\r\n        final String sql = \"INSERT INTO member (memId, memPw, memMail) values (?,?,?)\";\r\n        pstmt = conn.prepareStatement(sql);\r\n        pstmt.setString(1, member.getMemId());\r\n        pstmt.setString(2, member.getMemPw());\r\n        pstmt.setString(3, member.getMemMail());\r\n        result = pstmt.executeUpdate();\r\n        // SQL 관련 부분 끝\r\n    } catch (ClassNotFoundException e) {\r\n        e.printStackTrace();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        try {\r\n            if(pstmt != null) pstmt.close();\r\n            if(conn != null) conn.close();\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\t\r\n    return result;\r\n\r\n}\r\n```\r\n\r\nJDBC와 DriverManager를 사용해서 데이터베이스에 접근하는 위의 코드는 다음과 같은 문제점이 있습니다\r\n\r\n1. 데이터베이스에 접속할 때마다 새로운 Connection 객체를 만들기 때문에 접속량이 많아지면 서버에 큰 부하를 일으키게 됩니다.\r\n2. Insert, Update 등 데이터베이스에 접근하는 모든 메소드마다 드라이버 로딩, 연결, 자원 해제 코드를 작성하는 구조적인 반복이 발생합니다.\r\n\r\n\r\n\r\n## Connection Pool\r\n\r\n> DB 연결을 미리 준비해 놓고 사용하는 방법\r\n\r\n데이터베이스에 접속할 때마다 매번 연결을 하고 Connection 객체를 만드는 일은 비효율적이고 서버에 부하를 일으키는 방식입니다.\r\n\r\nConnection Pool은 WAS가 실행될 때 여러 개의 Connection을 미리 만들어 Pool에 저장해두고, 요청이 들어오면 Pool에 있던 Connection을 제공하고 처리가 끝나면 다시 반납받아 Pool에 저장하는 기법입니다.\r\n\r\n\r\n\r\nConnection Pool을 사용하면 **빠르게 데이터베이스에 접속이 가능**하고, Connection 객체의 수가 제한되어 있어 접속량이 많더라도 **서버 자원을 필요 이상으로 사용하지 않기** 때문에 Connection Pool은 대규모 웹 서비스를 제공할 때 필수적인 요소입니다.\r\n\r\n\r\n\r\n[장점]\r\n\r\n1. 미리 연결이 되어있기 때문에 빠르게 DB 접속 가능\r\n2. DB 연결 수 제한으로 서버 자원 고갈 방지\r\n3. DB 접속 모듈 공통화로 편리한 유지보수\r\n4. Connection 객체를 새로 만드는 비용 절약\r\n\r\n\r\n\r\n### DataSource\r\n\r\n효율적인 데이터베이스 연결을 위한 Connection Pool, 즉 DBCP (Database Connection Pool) 기능으로 구현한 구현체들이 많이 생겼지만 표준이 없었기 때문에 구현체마다 내용이 달라 관리가 어려웠습니다. DataSource Interface는 이런 문제를 해결하기 위해 만들어진 DBCP 구현체들의 표준입니다.\r\n\r\n> The **DataSource** interface is implemented by a driver vendor. There are three types of implementations:\r\n>\r\n> 1. Basic implementation -- produces a standard **Connection** object\r\n> 2. Connection pooling implementation -- produces a **Connection** object that will automatically participate in connection pooling. This implementation works with a middle-tier connection pooling manager.\r\n> 3. Distributed transaction implementation -- produces a **Connection** object that may be used for distributed transactions and almost always participates in connection pooling. This implementation works with a middle-tier transaction manager and almost always with a connection pooling manager.\r\n\r\n[[출처](https://docs.oracle.com/javase/7/docs/api/javax/sql/DataSource.html)]\r\n\r\nDataSource 인터페이스에는 Connection 객체 생성과 Connection Pool에 대한 내용이 있습니다.\r\n\r\nDataSource는 Connection Pool을 통해 DriverManager를 한 단계 더 추상화 한 형태입니다. DriverManager는 실질적인 접속을 생성하며 close 메소드가 실제 접속을 종료하지면 DataSource는 논리적인 접속을 생성하며 close 메소드가 실제 접속을 종료하는 것이 아니라 Connection Pool로 관리하고 있는 접속 중 하나를 논리적으로 종료합니다.\r\n\r\n\r\n\r\n❗ DataSource는 Java의 표준으로 지정되어 있어서 사용법이 동일하지만 Connection Pool의 표준은 없기 때문에 Connection Pool은 라이브러리에 따라 달라집니다.\r\n\r\n❗ 스프링에서 제공하는 **org.springframework.jdbc.datasource.DriverManagerDataSource**는 Connection Pool 기능이 없는 개발 단계에서만 사용 가능한 DataSource입니다.\r\n\r\n\r\n\r\n#### DBCP 구현체\r\n\r\nDBCP를 구현한 라이브러리의 종류\r\n\r\n- [**Apache Commons DBCP**](https://commons.apache.org/proper/commons-dbcp/)\r\n- [**HikariCP**](https://github.com/brettwooldridge/HikariCP )\r\n- [**c3p0**](https://github.com/swaldman/c3p0 )\r\n\r\n\r\n\r\n## JDBC Template\r\n\r\n> JDBC의 구조적인 반복을 줄이기 위한 클래스\r\n\r\nJava에서 제공하는 JDBC를 사용한 기존 코드는 SQL문과 관련된 부분을 제외하고 **드라이버 로딩, DB 연결, 자원 해제** 부분이 반복됩니다.\r\n\r\nJDBC Template은 이런 구조적인 반복을 줄이고 개발자가 SQL문만 작성하도록 만들어 생산성과 유지보수성을 높이기 위해 Spring Framework에서 제공하는 클래스입니다. \r\n\r\nJDBC Template은 Driver를 논리적인 레벨에서 다루기 때문에 DriverManager가 아닌 DataSource를 주입해서 사용합니다.\r\n\r\n\r\n\r\n- **DataSource - No Connection Pool**\r\n  - c3p0 : **com.mchange.v2.c3p0.DriverManagerDataSource**\r\n  - 스프링 : **org.springframework.jdbc.datasource.DriverManagerDataSource**\r\n- **DataSource - With Connection Pool**\r\n  - c3p0 : **com.mchange.v2.c3p0.ComboPooledDataSource**\r\n  - dbcp : **org.apache.commons.dbcp.BasicDataSource**\r\n\r\n\r\n\r\n---\r\n\r\n## 사용하기\r\n\r\n### JDBC Template\r\n\r\n#### 의존설정 추가 (pom.xml)\r\n\r\n```xml\r\n<!-- 오라클을 사용하는 경우 : 오라클 Driver 관리를 위한 오라클 레파지토리 추가(메이븐 레파지토리에 없음) -->\r\n<repositories> <!-- 기존 -->\r\n\t<repository>\r\n    \t<id>oracle</id>\r\n        <name>ORACLE JDBC Repository</name>\r\n        <url>http://maven.jahia.org/maven2</url>\r\n    </repository>\r\n</repositories>\r\n\r\n...\r\n\r\n<!-- DB -->\r\n<dependency> <!-- 기존 DB 의존설정 -->\r\n\t<groupId>com.oracle</groupId>\r\n    <artifactId>objdbc6</artifactId>\r\n    <version>12.1.0.2</version>\r\n</dependency>\r\n<dependency> <!-- 스프링에서 제공하는 기본적인 JDBC를 사용하는 경우 추가 -->\r\n\t<groupId>org.springframework</groupId>\r\n    <artifactId>spring-jdbc</artifactId>\r\n    <version>4.1.6.RELEASE</version>\r\n</dependency>\r\n<dependency> <!-- C3P0를 사용하는 경우 : JDBC 커넥션 풀을 지원하는 C3P0 모듈을 사용하는 경우 추가 -->\r\n\t<groupId>com.mchange</groupId>\r\n    <artifactId>c3p0</artifactId>\r\n    <version>0.9.5</version>\r\n</dependency>\r\n```\r\n\r\n#### 템플릿 사용 (dao.java)\r\n\r\n```java\r\n@Repository\r\npublic class MemberDao implements IMmeberDao {\r\n    \r\n    private String driver = \"oracle.jdbc.driver.OracleDriver\";\r\n    private String url = \"jdbc:oracle:thin:@localhost:1521:xe\";\r\n    private String userid = \"scott\";\r\n    private String userpw = \"tiger\";\r\n    \r\n    /* 1) template, dataSource 객체 생성 */\r\n    private DriverManagerDataSource dataSource; // c3p0 dataSource 사용하는 경우\r\n    org.springframework.jdbc.datasource.DriverManagerDataSource dataSource // spring 제공 dataSource 사용하는 경우\r\n        \r\n    private JdbcTemplate template; // template 객체 생성\r\n    \r\n    /* 2) 생성자 */\r\n    // c3p0 dataSource 사용\r\n    public MemberDao() {\r\n        dataSource = new DriverManagerDataSource();\r\n        dataSource.setDriverClass(driver); // 1-0) 드라이버 로딩 준비\r\n        dataSource.setJdbcUrl(url); // 2-0) DB 연결 준비\r\n        dataSource.setUser(userid); // 2-0) DB 연결 준비\r\n        dataSource.setPassword(userpw); // 2-0) DB 연결 준비\r\n        \r\n    \ttemplate = new JdbcTemplate();\r\n        template.setDataSource(dataSource);\r\n    }\r\n    // spring dataSource 사용\r\n    public MemberDao() {\r\n        dataSource = new org.springframework.jdbc.datasource.DriverManagerDataSource();\r\n        dataSource.setDriverClassName(driver); // 1-0) 드라이버 로딩 준비\r\n        dataSource.setUrl(url); // 2-0) DB 연결 준비\r\n        dataSource.setUsername(userid); // 2-0) DB 연결 준비\r\n        dataSource.setPassword(userpw); // 2-0) DB 연결 준비\r\n    \r\n    \ttemplate = new JdbcTemplate();\r\n        template.setDataSource(dataSource);\r\n    }\r\n    \r\n    ... // 이후 각 Method 코드는 아래에\r\n}\r\n```\r\n\r\n##### Insert Method\r\n\r\n> update() 사용\r\n\r\n```java\r\n// 방법 1\r\n@Override\r\npublic int memberInsert(Member member) {\r\n\t\r\n    int result = 0;\r\n    \r\n    final String sql = \"INSERT INTO member (memId, memPw, memMail) values (?,?,?)\";\r\n    result = template.update(sql, member.getMemId(), member.getMemPw(), member.getMemMail());\r\n    \r\n    return result;\r\n\r\n}\r\n```\r\n\r\n```java\r\n// 방법 2\r\n@Override\r\npublic int memberInsert(Member member) {\r\n\t\r\n    int result = 0;\r\n    \r\n    final String sql = \"INSERT INTO member (memId, memPw, memMail) values (?,?,?)\";\r\n    result = template.update(new PreparedStatementCreator() {\r\n\t\t@Override\r\n\t\tpublic PreparedStatement createPreparedStatement(Connection conn)\r\n\t\t\t\tthrows SQLException {\r\n\t\t\tPreparedStatement pstmt = conn.prepareStatement(sql);\r\n\t\t\tpstmt.setString(1, member.getMemId());\r\n\t\t\tpstmt.setString(2, member.getMemPw());\r\n\t\t\tpstmt.setString(3, member.getMemMail());\r\n\t\t\t\r\n\t\t\treturn pstmt;\r\n\t\t}\r\n\t});\r\n     \r\n    return result;\r\n\r\n}\r\n```\r\n\r\n```java\r\n// 방법 3\r\n@Override\r\npublic int memberInsert(Member member) {\r\n\t\r\n    int result = 0;\r\n    \r\n    final String sql = \"INSERT INTO member (memId, memPw, memMail) values (?,?,?)\";\r\n    result = template.update(sql, new PreparedStatementSetter() {\t\t\r\n\t\t@Override\r\n\t\tpublic void setValues(PreparedStatement pstmt) throws SQLException {\r\n\t\t\tpstmt.setString(1, member.getMemId());\r\n\t\t\tpstmt.setString(2, member.getMemPw());\r\n\t\t\tpstmt.setString(3, member.getMemMail());\t\t\t\t\r\n\t\t}\r\n\t});\r\n     \r\n    return result;\r\n\r\n}\r\n```\r\n\r\n##### Select Method\r\n\r\n> query() 사용\r\n\r\n```java\r\n// 방법 1\r\n@Override\r\npublic Member memberSelect(Member member) {\r\n\t\r\n    List<Member> members = null;\r\n    \r\n    final String sql = \"SELECT * FROM member WHERE memId = ? AND memPw = ?\";\r\n    members = template.query(sql, \r\n\tnew RowMapper<Member>() {\r\n\t\t@Override\r\n\t\tpublic Member mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n\t\t\tMember mem = new Member();\r\n\t\t\tmem.setMemId(rs.getString(\"memId\"));\r\n\t\t\tmem.setMemPw(rs.getString(\"memPw\"));\r\n\t\t\tmem.setMemMail(rs.getString(\"memMail\"));\r\n\t\t\tmem.setMemPurcNum(rs.getInt(\"memPurcNum\"));\r\n\t\t\treturn mem;\r\n\t\t}\r\n\t},\r\n    member.getMemId(), member.getMemPw());\r\n    \r\n    if (members.isEmpty()) return null;\r\n    \r\n    return members.get(0);\r\n\r\n}\r\n```\r\n\r\n```java\r\n// 방법 2\r\n@Override\r\npublic Member memberSelect(Member member) {\r\n\t\r\n    List<Member> members = null;\r\n    \r\n    final String sql = \"SELECT * FROM member WHERE memId = ? AND memPw = ?\";\r\n    members = template.query(sql, \r\n\t\tnew Object[]{member.getMemId(), member.getMemPw()},\r\n\t\tnew RowMapper<Member>() {\r\n            @Override\r\n            public Member mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n                Member mem = new Member();\r\n                mem.setMemId(rs.getString(\"memId\"));\r\n                mem.setMemPw(rs.getString(\"memPw\"));\r\n                mem.setMemMail(rs.getString(\"memMail\"));\r\n                mem.setMemPurcNum(rs.getInt(\"memPurcNum\"));\r\n                return mem;\r\n            }\r\n    });\r\n    \r\n    if (members.isEmpty()) return null;\r\n    \r\n    return members.get(0);\r\n\r\n}\r\n```\r\n\r\n##### Update Method\r\n\r\n> update() 사용\r\n\r\n```java\r\n@Override\r\npublic int memberUpdate(Member member) {\r\n\t\r\n    int result = 0;\r\n    \r\n    final String sql = \"UPDATE member SET memPw = ?, memMail = ? WHERE memId = ?\";\r\n    result = template.update(sql, member.getMemPw(), member.getMemMail(),  member.getMemId());\r\n\t\r\n    return result;\r\n\r\n}\r\n```\r\n\r\n##### Delete Method\r\n\r\n> update() 사용\r\n\r\n```java\r\n@Override\r\npublic int memberDelete(Member member) {\r\n\t\r\n    int result = 0;\r\n    \r\n    final String sql = \"DELETE member WHERE memId = ? AND memPw = ?\";\r\n    result = template.update(sql, member.getMemId(), member.getMemPw());\r\n\t\r\n    return result;\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### Connection Pool\r\n\r\n#### c3p0 모듈의 ComboPooledDataSource\r\n\r\n> **com.mchange.v2.c3p0.ComboPooledDataSource**를 사용한 Connection Pool\r\n\r\n```java\r\n@Repository\r\npublic class MemberDao implements IMmeberDao {\r\n    ...\r\n        \r\n    // template, dataSource 객체 생성\r\n    private ComboPooledDataSource dataSource; // c3p0 모듈의 ComboPooledDataSource\r\n    private JdbcTemplate template; // JDBC Template\r\n    \r\n    // 생성자 (c3p0의 DriverManagerDataSource와 동일)\r\n    public MemberDao() {\r\n        dataSource = new ComboPooledDataSource();\r\n        try {\r\n            dataSource.setDriverClass(driver); // 1-0) 드라이버 로딩 준비\r\n            dataSource.setJdbcUrl(url); // 2-0) DB 연결 준비\r\n            dataSource.setUser(userid); // 2-0) DB 연결 준비\r\n            dataSource.setPassword(userpw); // 2-0) DB 연결 준비\r\n        } catch (PropertyVetoException e) {\r\n            e.printStackTrace();\r\n        }\r\n        \r\n    \ttemplate = new JdbcTemplate();\r\n        template.setDataSource(dataSource);\r\n    }\r\n    \r\n    ... // 이후 각 Method 코드는 아래에\r\n}\r\n```\r\n\r\n(dao.java)\r\n\r\n특이사항으로는 ComboPooledDataSource를 이용한 DataSource 생성자는 반드시 예외처리를 해 줘야 함\r\n\r\n#### DataSource Bean 객체 설정 (servlet-context.xml)\r\n\r\n> 스프링 설정파일을 이용한 Connection Pool 객체 생성\r\n\r\n```xml\r\n<beans:bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\r\n    <beans:property name=\"driverClass\" value=\"oracle.jdbc.driver.OracleDriver\" />\r\n    <beans:property name=\"jdbcUrl\" value=\"jdbc:oracle:thin:@localhost:1521:xe\" />\r\n    <beans:property name=\"user\" value=\"scott\" />\r\n    <beans:property name=\"password\" value=\"tiger\" />\r\n    <beans:property name=\"maxPoolSize\" value=\"200\" />\r\n    <beans:property name=\"checkoutTimeout\" value=\"60000\" />\r\n    <beans:property name=\"maxIdleTime\" value=\"1800\" />\r\n    <beans:property name=\"idleConnectionTestPeriod\" value=\"600\" />\r\n</beans:bean>\r\n```\r\n\r\n(WEB-INF / spring / appServlet / **servlet-context.xml**)\r\n\r\n스프링 설정파일을 이용해서 ComboPooledDataSource 빈(bean) 객체를 만들어 놓는 방법입니다.\r\n\r\n이렇게 설정파일에서 Bean 객체를 만들어놓으면 Dao에서 자동주입으로 객체를 사용할 수 있습니다.\r\n\r\n```java\r\n@Repository\r\npublic class MemberDao implements IMmeberDao {\r\n    ...\r\n        \r\n    private JdbcTemplate template; // JDBC Template\r\n    \r\n    @Autowired\r\n    public MemberDao(ComboPooledDataSource dataSource) {\r\n        this.template = new JdbcTemplate(dataSource);\r\n    }\r\n    \r\n    ... // 이후 각 Method 코드는 아래에\r\n}\r\n```\r\n\r\n스프링을 쓰는 가장 큰 이유 중 하나가 스프링 설정파일에 만든 Bean 객체를 활용하기 위함이며, 데이터베이스 관련 정보를 따로 관리할 수 있기 때문에 유지보수에도 좋은 방법입니다.\r\n\r\n→ **이 방식이 Spring Framework에서 DataBase를 이용하는 가장 일반적인 방법** (`최종 결과물`)\r\n\r\n\r\n\r\n#### (추가) Java의 Config를 이용해 Bean 객체를 만드는 방법\r\n\r\n원한다면 xml 형태의 스프링 설정파일이 아니라 Java 파일의 Config를 이용해 Bean 객체 만들 수 있습니다.\r\n\r\n물론 Database 관련 파일을 굳이 Java 파일로 만들기 보단 xml로 분리시켜 놓는 것이 낫기 때문에 추천하진 않습니다.\r\n\r\n```java\r\npackage com.jw.lec25.config;\r\n\r\nimport java.beans.PropertyVetoException;\r\n\r\n@Configuration\r\npublic class DBConfig {\r\n    \r\n    @Bean\r\n    public ComboPooledDataSource dataSource() throws PropertyVetoException {\r\n        ComboPooledDataSource dataSource = new ComboPooledDataSource();\r\n        \r\n        dataSource.setDriverClass(\"oracle.jdbc.driver.OracleDriver\");\r\n        dataSource.setJdbcUrl(\"jdbc:oracle:thin:@localhost:1521:xe\");\r\n        dataSource.setUser(\"scott\");\r\n        dataSource.setPassword(\"tiger\")\r\n        dataSource.setMaxPoolSize(200);\r\n        dataSource.setCheckoutTimeout(6000);\r\n        dataSource.setMaxIdleTime(1800);\r\n        dataSource.setidleConnectionTestPeriod(600);\r\n        \r\n        return dataSource;\r\n        \r\n    }\r\n    \r\n}\r\n```\r\n\r\n(DBConfig.java)\r\n\r\n\r\n\r\n## 정리\r\n\r\n![image-20211231004958032](../../../../public/assets/image-20211231004958032.png)\r\n\r\n정리하자면 다음과 같습니다.\r\n\r\n1. Database Connection Pool, DBCP는 데이터베이스 연결을 논리적인 레벨에서 관리하기 위한 기능으로 이를 구현한 DBCP 구현체들은 여러 종류가 있습니다.\r\n2. DataSource Interface는 각 벤더사마다 DBCP 구현체를 다르게 만드는 것을 통일시키기 위한 DBCP 구현체의 표준 입니다.\r\n3. DBCP의 종류로는 Apache Commons DBCP, HikariCP, c3p0가 있습니다.\r\n4. JDBC Template은 JDBC를 이용했을 때 반복되는 구조를 개선하기 위해 Spring Framework에서 제공하는 클래스입니다.\r\n5. JDBC Template은 DataSource를 주입해서 사용합니다.\r\n6. Spring에서 제공하는 DataSource도 있지만 여기에는 Connection Pool이 없습니다. (DataSource는 Java 표준이 있지만 그 표준에 Connection Pool는 포함되어 있지 않습니다)\r\n\r\n\r\n\r\n- JDBC Template 외에 JPA/Hibernate, MyBatis를 사용할 수도 있습니다. (이에 대해선 다음에 소개하도록 하겠습니다)\r\n\r\n\r\n\r\n\r\n\r\n## 출처\r\n\r\n인프런 - 자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌\r\n\r\nhttps://preamtree.tistory.com/88\r\n\r\nhttps://bamdule.tistory.com/167\r\n\r\nhttps://aljjabaegi.tistory.com/402\r\n\r\nhttps://jaehoney.tistory.com/33\r\n\r\nhttps://jaehoney.tistory.com/34\r\n\r\nhttps://hasiki.tistory.com/87\r\n\r\nhttps://pangtrue.tistory.com/81\r\n\r\nhttps://opentogether.tistory.com/95\r\n\r\nhttps://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=mky1416&logNo=220647254648\r\n\r\nhttps://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hahava&logNo=221369200088\r\n\r\nhttps://linked2ev.github.io/spring/2019/08/14/Spring-3-%EC%BB%A4%EB%84%A5%EC%85%98-%ED%92%80%EC%9D%B4%EB%9E%80/\r\n\r\nhttps://minkwon4.tistory.com/168\r\n\r\nhttps://www.allinterview.com/showanswers/115022/what-is-the-difference-between-connection-pool-and-data-source.html\r\n\r\nhttps://pangtrue.tistory.com/106\r\n\r\nhttps://repacat.tistory.com/23\r\n\r\nhttps://gmlwjd9405.github.io/2018/12/19/jdbctemplate-usage.html\r\n","documentTitle":"[Spring] Connection Pool과 JDBC Template"},"__N_SSG":true}