{"pageProps":{"markdown":"# Java Thread.run()과 Thread.start()의 차이\r\n\r\n이벤트 루프를 만들면서 생긴 일이다.\r\n\r\nThread 클래스를 상속받은 Loop 클래스를 만들고 run() 메서드를 구현했다.\r\n\r\n이벤트 루프 작업을 위해 run() 메서드 안에는 무한루프 문이 있었는데, @PostConstruct 어노테이션을 붙인 init() 메서드에서 Thread.run()을 실행시키니 스프링 어플리케이션의 다른 기능이 동작하지 않는 문제가 생겼다.\r\n\r\n요청도 안 받아지고 무한루프 문 외에는 아무 것도 동작하지 않았다.\r\n\r\nThread를 새로 만들어 할당해보기도 하고 여러 방법을 시도해 봤지만 소용없었다.\r\n\r\n이는 내가 Thread 클래스의 run()과 start()의 차이를 몰랐기 때문이다.\r\n\r\n\r\n\r\n## run()\r\n\r\nThread 클래스의 run() 메서드를 찾아보면 다음과 같이 나온다.\r\n\r\n```java\r\n@Override\r\npublic void run() {\r\n   if (target != null) {\r\n      target.run();\r\n   }\r\n}\r\n```\r\n\r\n\r\n\r\n## start()\r\n\r\n그리고 start() 메서드는 다음과 같다.\r\n\r\n```java\r\npublic synchronized void start() {\r\n   /**\r\n   * This method is not invoked for the main method thread or \"system\"\r\n   * group threads created/set up by the VM. Any new functionality added\r\n   * to this method in the future may have to also be added to the VM.\r\n   *\r\n   * A zero status value corresponds to state \"NEW\".\r\n   */\r\n   if (threadStatus != 0)\r\n      throw new IllegalThreadStateException();\r\n\r\n   /* Notify the group that this thread is about to be started\r\n   * so that it can be added to the group's list of threads\r\n   * and the group's unstarted count can be decremented. */\r\n   group.add(this);\r\n\r\n   boolean started = false;\r\n   try {\r\n      start0();\r\n      started = true;\r\n   } finally {\r\n      try {\r\n            if (!started) {\r\n               group.threadStartFailed(this);\r\n            }\r\n      } catch (Throwable ignore) {\r\n            /* do nothing. If start0 threw a Throwable then\r\n            it will be passed up the call stack */\r\n      }\r\n   }\r\n}\r\n```\r\n\r\n\r\n\r\n## 결론\r\n\r\n즉 run()은 단순히 메서드를 실행하고 끝이고\r\n\r\nstart()는 **native 함수인 start0()를 사용해서 멀티스레드 환경을 생성한 뒤 run() 메서드를 호출한다.**\r\n\r\n즉 Thread 클래스를 제대로 활용하려면 run()이 아니라 start()를 호출해야 한다.\r\n\r\n\r\n\r\n## 비교\r\n\r\n- run() : 싱글 스레드 / 단순 메서드 호출 / 메인 스레드의 stack 영역 차지 -> 끝나기 전까지 다른 메서드 호출 불가\r\n- start() : 멀티 스레드 / 네이티브 메서드 호출 / 새로운 스레드를 생성 후 stack 영역 차지 -> 독립적으로 동작 가능","documentTitle":"Java Thread.run()과 Thread.start()의 차이","index":[{"type":"type1","data":" Java Thread.run()과 Thread.start()의 차이"},{"type":"type2","data":" run()"},{"type":"type2","data":" start()"},{"type":"type2","data":" 결론"},{"type":"type2","data":" 비교"}]},"__N_SSG":true}