{"pageProps":{"markdown":"# 그래프 유형\r\n\r\n> 정점(Node)과 간선(Edge)으로 이어진 자료구조\r\n\r\n**\"점과 선으로 이어진 데이터\"**\r\n\r\n그래프 문제는 \"`공식`\"이 중요하다.\r\n\r\n각 유형마다 사용하는 특유의 방법이 있고 이를 바로바로 활용할 수 있는 능력이 문제를 풀 때 요구된다. (시간이 충분하다면 고민하면서 찾아볼 수 있겠지만 실제 시험에선 그렇게 오래 즐길 시간이 주어지지 않는다)\r\n\r\n\r\n\r\n방향 유무, 사이클 유무, 가중치 유무 등에 따라 구분될 수 있지만 지금은 문제 유형에 집중\r\n\r\n(그래프의 일종인 트리는 따로 다룰 계획)\r\n\r\n\r\n\r\n## 그래프 표현법\r\n\r\n![](../../../../public/assets/2022-08-04-22-54-31-image.png)\r\n\r\n(예시 그래프)\r\n\r\n\r\n\r\n1. 인접 행렬\r\n\r\n```\r\n[\r\n    [0,1,0],\r\n    [1,0,1],\r\n    [0,1,0]\r\n]\r\n```\r\n\r\n각 노드마다 대응되는 배열이 있으며 **모든 노드에 대한 연결 상태**를 표현\r\n\r\n- 두 노드가 연결되어 있는지 확인하는 것이 빠름\r\n\r\n- 특정 노드와 연결된 모든 노드를 찾는 건 느림 (간선이 많을수록 유리)\r\n\r\n- 많은 메모리 사용 (고정된 n^2 만큼의 메모리 필요)\r\n\r\n\r\n\r\n2. 인접 리스트\r\n\r\n```\r\n[\r\n    [1],\r\n    [0,2],\r\n    [1]\r\n]\r\n```\r\n\r\n각 노드마다 대응되는 리스트가 있으며 **연결된 노드만** 표현\r\n\r\n- 두 노드가 연결되어 있는지 확인하는 것이 느림\r\n\r\n- 특정 노드와 연결된 모든 노드를 찾는 건 빠름 (간선이 적을수록 유리)\r\n\r\n- 필요한 메모리 사용\r\n\r\n\r\n\r\n3. 간선 리스트\r\n\r\n```\r\n[\r\n    [0,1],\r\n    [1,2]\r\n]\r\n```\r\n\r\n**엣지**만 표현\r\n\r\n간선 위주로 문제를 풀어가는 크루스칼 알고리즘에서 사용\r\n\r\n\r\n\r\n## 문제 유형\r\n\r\n### DFS, BFS\r\n\r\n- DFS : 연결 노드를 `Stack`에 담음\r\n  - 모든 노드를 방문할 때 좋음\r\n  - 일단 멀리까지 가야하는 경우 조기 탐색 가능성이 있음 (깊이 찌르면서 가기 때문)\r\n    - 대신 얻은 해가 <u>최단 경로라는 보장이 없음</u>\r\n  - 사이클 탐지 / 위상 정렬에 적합\r\n\r\n\r\n\r\n- BFS : 연결 노드를 `Queue`에 담음 (`from collections import deque`)\r\n  - **최단 경로 탐색** (가중치가 없는 경우)\r\n  - 효율적으로 움직여야 하는 경우 좋음 (가까이 있는 노드부터 탐색하며 이동하기 때문)\r\n  - **가중치가 없는 그래프의 최단 경로는 BFS로 접근**\r\n\r\n\r\n\r\n#### 백트래킹\r\n\r\n`유망성 검사`를 통해 **가지치기**를 하는 것\r\n(일반적으로 DFS에서 많이 사용하지만 BFS에서도 사용 가능)\r\n\r\n즉 더이상 진행해봤자 무의미한 루트는 Stack이나 Queue에 담지 않고 버리는 것\r\n\r\n```python\r\n# N-Queen 문제\r\n# https://www.acmicpc.net/problem/9663\r\n\r\nimport sys\r\ninput = sys.stdin.readline\r\n\r\nN = int(input())\r\n\r\ncount = 0\r\nqueens = [[0,{i},{i},{i}] for i in range(N)] # row, column, 우하, 우상\r\n\r\nwhile queens:\r\n    queen = queens.pop()\r\n    \r\n    # 가지치기 단계\r\n    if queen[0]+1 == N:\r\n        count += 1\r\n        continue\r\n\r\n    for next in range(N):\r\n        if next not in queen[1] and next-(queen[0]+1) not in queen[2] and next+(queen[0]+1) not in queen[3]:\r\n            queens.append([queen[0]+1, queen[1] | {next}, queen[2] | {next-queen[0]-1}, queen[3] | {next+queen[0]+1}]) # 우하 대각선은 x-y, 우상 대각선은 x+y와 같다.\r\n\r\nprint(count)\r\n```\r\n\r\n\r\n### 최소 신장 트리 (Minimum Spanning Tree; MST)\r\n```\r\n신장 트리 : N개의 정점이 N-1개의 간선을 가지는 한 줄로 이어진 그래프 (최소 연결 그래프)\r\n\r\n최소 신장 트리 : 가중치의 합이 최소가 되는 신장 트리\r\n```\r\n\r\nMST 문제는 **가중치가 있는 그래프**에서 가중치의 합이 최소가 되는 MST를 찾으라는 형식으로 나온다.\r\n\r\n이전에 소개한 그리디를 사용하여 해결할 수 있는 유형이다.\r\n\r\n#### 프림 알고리즘 (Prim)\r\n\r\n`간선이 많을 때 사용` - **간만프**\r\n\r\n**하나의 정점에서 연결된 간선 중 최소 비용 간선 선택** (정점 위주)\r\n\r\n[활용]\r\n\r\n```python\r\n# 세팅\r\nINF = 999999999\r\nV, E = map(int,input().split())\r\nadj = [[987654321] * (V+1) for _ in range(V+1)]\r\nfor i in range(E):\r\n    start, end, weight = map(int, input().split())\r\n    adj[start][end] = adj[end][start] = weight\r\n\r\n# Prim 시작\r\ndistance = [INF] * (V+1) # Spanning Tree로부터 정점까지의 거리\r\nvisited = [False] * (V+1) # Spanning Tree에 추가 여부\r\n\r\ndistance[V] = 0\r\n\r\nfor _ in range(V): # 정점 V개를 돌면서 연결\r\n    min_idx = -1\r\n    min_value = INF\r\n\r\n    # 최소 거리인 노드 선택\r\n    for i in range(V+1):\r\n        if not visited[i] and distance[i] < min_value:\r\n            min_idx = i\r\n            min_value = distance[i]\r\n    visited[min_idx] = True\r\n    # 새로 추가된 노드에 대해 거리 갱신\r\n    for i in range(V+1):\r\n        if not visited[i] and adj[min_idx][i] < distance[i]:\r\n            distance[i] = adj[min_idx][i]\r\n\r\nprint(sum(dist)) # MST 가중치의 합\r\n```\r\n\r\n1. 임의의 정점 선택\r\n2. 인접 정점 중 **최소 비용의 간선을 가지는 정점** 선택\r\n   - 여기서 인접 정점은 신장 트리와 연결된 모든 정점이 대상\r\n3. 2를 반복\r\n\r\n\r\n\r\n#### 크루스칼 알고리즘 (Kruskal)\r\n\r\n`간선이 적을 때 사용` - **간적프**\r\n\r\n**트리의 모든 간선을 대상으로 최소 비용 간선을 하나씩 선택** (최소 비용 간선 위주)\r\n\r\n크루스칼 알고리즘에서는 사이클 검증이 필요하기 때문에 \"상호 배타 집합\"을 활용한다\r\n\r\n[활용]\r\n\r\n```python\r\n# 상호배타집합\r\ndef make_set(x):\r\n    p[x] = x\r\n\r\ndef find_set(x):\r\n    if p[x] != x:\r\n        p[x] = find_set(p[x])\r\n    return p[x]\r\n\r\ndef union(x, y):\r\n    p[find_set(y)] = find_set(x)\r\n\r\n# 세팅\r\nINF = 999999999\r\nV, E = map(int,input().split())\r\nedges = [list(map(int, input().split())) for _ in range(E)] # 간선 리스트\r\nedges.sort(key=lambda x: x[2]) # 간선을 가중치 순으로 오름차순 정렬\r\n\r\n# 상호배타집합 p\r\np = [0]*(V + 1)\r\n# 처음에는 각 노드가 독립적이기 때문에 각각 상호배타집합을 생성\r\nfor i in range(V + 1):\r\n    make_set(i)\r\n\r\n# Kruskal 시작\r\nsum_mst = 0 # 가중치의 합\r\ncnt = 0  # 간선 선택 횟수\r\nidx = 0  # 간선의 인덱스 (가장 가중치가 낮은 0번부터 선택)\r\n\r\nwhile cnt < V:\r\n    x = edges[idx][0]\r\n    y = edges[idx][1]\r\n\r\n    if find_set(x) != find_set(y): # 사이클이 형성되는지 확인 (서로 상호 배타 집합인지)\r\n        union(x, y)\r\n        cnt += 1\r\n        sum_mst += edges[idx][2]\r\n    idx += 1\r\n\r\nprint(sum_mst) # MST 가중치의 합\r\n```\r\n\r\n1. 가중치에 따라 **간선을 오름차순 정렬**\r\n2. 가중치가 낮은 간선부터 추가\r\n   - 만약 사이클이 만들어지는 간선이면 Pass (상호 배타 집합 활용)\r\n4. 2를 반복\r\n\r\n#### + 상호 배타 집합 (Disjoint Set)\r\n\r\n크루스칼 알고리즘에서 사이클이 형성되는지 확인해야 하는데, 이는 \"두 집합이 **상호 배타 집합**인지 확인\"하는 것으로 검증할 수 있다.\r\n\r\n자세한 설명은 [이 글](https://parkjeongwoong.github.io/articles/Algorithm/0)을 참고하고 이 글에서는 사용 방법만 알아보자\r\n\r\n[활용]\r\n\r\n- **Make-Set(x)** : 유일한 멤버 x를 포함하는 새로운 집합 생성\r\n- **Find-Set(x)** - x를 포함하는 집합 탐색, return representative\r\n- **Union(x, y)** - x와 y를 포함하는 두 집합을 통합 / 집합 y의 대표를 집합 x의 대표로 바꾸는 것\r\n\r\n```python\r\ndef make_set(x):\r\n    p[x] = x\r\n\r\ndef find_set(x):\r\n    if p[x] != x:\r\n        p[x] = find_set(p[x])\r\n    return p[x]\r\n\r\ndef union(x, y):\r\n    p[find_set(y)] = find_set(x)\r\n\r\np = [0]*(3)\r\nmake_set(0)\r\nmake_set(1)\r\nmake_set(2)\r\n# p = [0, 1, 2] ; p[i] = i로 각 원소들은 자기 자신 뿐인 집합을 가진다\r\n\r\nunion(0, 1)\r\n# p = [0, 0, 2] ; 0과 1은 모두 대표값이 0인 동일한 집합에 속하게 되었다\r\n\r\nunion(1, 2)\r\n# p = [0, 0, 1] ; 2의 대표값은 1이지만 1의 대표값이 0이므로 셋 다 모두 최종 대표값이 0인 동일한 집합이 되었다\r\n\r\nfind_set(0) # 0\r\nfind_set(1) # 0\r\nfind_set(2) # 0\r\n# 0, 1, 2 모두 동일한 집합 0에 속하게 된다\r\n```\r\n\r\n상호 배타 집합의 깊이가 깊어질수록 연산 속도가 저하되는데 이에 대한 보다 자세한 내용은 [이 글](https://parkjeongwoong.github.io/articles/Algorithm/0)의 \"상호배타 집합 자료구조 (Disjoint-sets)\" 항목에 간단히 설명되어 있다\r\n\r\n\r\n\r\n### 최단 경로 (가중치가 있는 경우)\r\n\r\n가중치가 없는 그래프는 BFS로 찾을 수 있지만 가중치가 있는 그래프에선 다른 방법이 필요하다.\r\n\r\n#### 다익스트라 알고리즘 (Dijkstra)\r\n\r\n> 중점에서 다른 모든 점까지의 최단 경로\r\n\r\n어떤 노드에서 다른 모든 노드까지의 최단 경로를 찾는 알고리즘\r\n\r\n이 조건이 있는데, **음의 가중치가 허용되지 않는 것**이다.\r\n\r\n[활용]\r\n\r\n```python\r\ndef dijstra():\r\n    # 세팅\r\n    distance = [987654321]*(V+1)\r\n    visited = [False] * (V+1)\r\n    distance[0] = 0\r\n\r\n    for _ in range(V):\r\n        # 가장 가까운 노드를 찾는 과정\r\n        min_idx = -1\r\n        min_value = 987654321\r\n        for i in  range(V+1):\r\n            if not visited[i] and min_value > distance[i]:\r\n                min_value = distance [i]\r\n                min_idx = i\r\n        visited[min_idx] = True # 찾음\r\n        \r\n        # 선택한 노드를 기준으로 최단 거리 갱신 (중점에서 선택한 노드로 이동했다고 가정)\r\n        for i in range(V+1):\r\n            if not visited[i] and adj[min_idx][i] + distance[min_idx] < distance[i]:\r\n                distance[i] = adj[min_idx][i] + distance[min_idx]\r\n\r\n    return distance[V]\r\n\r\n\r\nfor tc in range(1, int(input())+1):\r\n    V, E = map(int , input().split())\r\n\r\n   adj = [[987654321]*(V+1) for _ in range(V+1)] # 인접 행렬\r\n\r\n   for i in range(E):\r\n        start, end , weight = map(int , input().split())\r\n        adj[start][end] = weight\r\n\r\n   print(\"#{} {}\".format(tc, dijstra()))\r\n```\r\n\r\n1. 중점으로 거리를 모두 최대값으로 초기화\r\n2. (아직 선택되지 않은 정점 중) 중점으로부터 거리가 최소인 정점을 선택\r\n3. 선택한 가장 가까운 정점을 방문해서 다른 정점으로 가는 경우의 수를 비교해서 최단 거리 갱신\r\n4. 2, 3 반복\r\n\r\n위의 소스코드가 헷갈릴 수 있는데 바깥 for문의 초회차 진행은 중점(0번)으로부터 다른 노드들 까지의 거리를 초기화 시켜주는 과정\r\n2회차부터 위에서 말한 \"중점으로부터 거리가 최소인 정점\"을 탐색하고 갱신하는 과정이 진행됨\r\n\r\n[heap을 사용한 방법]\r\n\r\n```python\r\n# 최단경로\r\n# https://www.acmicpc.net/problem/1753\r\n\r\nimport heapq\r\nimport sys\r\ninput = sys.stdin.readline\r\n\r\nV, E = map(int, input().split()) # 정점, 간선 개수\r\nstart_node = int(input()) # 시작 정점\r\nnodes = [[] for _ in range(V+1)] # 인접 리스트\r\nfor i in range(E):\r\n    from_node, to_node, cost = map(int,input().split())\r\n    nodes[from_node].append((to_node, cost)) # 방향과 가중치 저장\r\n\r\nvisited = ['INF']*(V+1) # 여기에 최소 비용을 저장\r\nvisited[start_node] = 0\r\n\r\nheap = []\r\nheapq.heappush(heap, (0, start_node))\r\n\r\nwhile heap:\r\n    cost, node = heapq.heappop(heap)\r\n\r\n    for next_node, next_cost in nodes[node]:\r\n        new_cost = cost+next_cost\r\n        if visited[next_node] == 'INF' or new_cost < visited[next_node]: # 최소 비용으로 갱신\r\n            visited[next_node] = new_cost\r\n            heapq.heappush(heap, (new_cost, next_node))\r\n```\r\n\r\nheap을 이용해서 최단거리 인접 정점을 찾고 거리를 갱신하는 방식\r\n\r\n\r\n\r\n#### (추가)\r\n\r\n이 알고리즘들은 추가적으로 알고 있으면 좋은 내용이다.\r\n\r\n##### 벨만-포드 알고리즘\r\n\r\n- 중점-다른 모든 점까지의 최단 경로\r\n- 음의 가중치 허용\r\n\r\n\r\n\r\n##### 플로이드-워샬 알고리즘\r\n\r\n- 모든 정점에 대한 최단 경로\r\n- 동적 계획 알고리즘 (DP)\r\n- 모든 부분에 대하여 [`직선거리 vs 경유거리`] 중 짧은 경로 선택을 반복\r\n- 이를 N*N 배열에서 계속 값을 갱신하면서 `O(N^3)` 시간만에 해답 도출\r\n  - 경유, 시작, 끝, 이렇게 3개에 대해서 반복문 3번 돌림\r\n  - 직선이 최단이면 직선 선택, **경유가 최단이면 경유에 대해서 다시 재귀 호출????**\r\n  - DP적으로 풀면 재귀가 필요 없음\r\n\r\n```python\r\nimport sys\r\ninput = sys.stdin.readline\r\n\r\nN, M = map(int, input().split())\r\n\r\nfloyd_warshall = [[100]*N for _ in range(N)] # 최대 99\r\n\r\nfor i in range(N):\r\n    floyd_warshall[i][i] = 0\r\n\r\nfor _ in range(M):\r\n    a,b = map(int, input().split())\r\n    floyd_warshall[a-1][b-1] = 1\r\n    floyd_warshall[b-1][a-1] = 1\r\n\r\nlocal_mins = 100\r\nlocal_min_idx = -1\r\n\r\nfor m in range(N):\r\n    for i in range(N):\r\n        for j in range(N):\r\n            floyd_warshall[i][j] = min(floyd_warshall[i][j], floyd_warshall[i][m]+floyd_warshall[m][j])\r\n    \r\nfor i in range(N):\r\n    kevin_bacon = sum(floyd_warshall[i])\r\n    if local_mins > kevin_bacon:\r\n        local_mins = kevin_bacon\r\n        local_min_idx = i\r\n\r\nprint(local_min_idx+1)\r\n```\r\n","documentTitle":"그래프 유형","index":[{"type":"type1","data":" 그래프 유형"},{"type":"type2","data":" 그래프 표현법"},{"type":"type2","data":" 문제 유형"},{"type":"type3","data":" DFS, BFS"},{"type":"type4","data":" 백트래킹"},{"type":"type3","data":" 최소 신장 트리 (Minimum Spanning Tree; MST)"},{"type":"type4","data":" 프림 알고리즘 (Prim)"},{"type":"type4","data":" 크루스칼 알고리즘 (Kruskal)"},{"type":"type4","data":" + 상호 배타 집합 (Disjoint Set)"},{"type":"type3","data":" 최단 경로 (가중치가 있는 경우)"},{"type":"type4","data":" 다익스트라 알고리즘 (Dijkstra)"},{"type":"type4","data":" (추가)"},{"type":"type5","data":" 벨만-포드 알고리즘"},{"type":"type5","data":" 플로이드-워샬 알고리즘"}]},"__N_SSG":true}