{"pageProps":{"markdown":"# Dynamic Programming 유형\r\n\r\n> 동적 계획법\r\n\r\n[문제를 풀 때 생각할 것]\r\n\r\n- 계산된 값을 `저장` -> 활용 (Memoization)\r\n- Memoization을 위한 `배열`이 필요\r\n\r\n\r\n\r\n## 유형1\r\n\r\n- Check or Pass\r\n  - **선택을 하는 경우 & 하지 않는 경우를 나누어서 생각**\r\n  - Memoization용 배열에 최종 결과값을 위한 인덱스 필요\r\n\r\n```python\r\n# https://www.acmicpc.net/problem/14501\r\n\r\nN = int(input())\r\nTimes = [0] * N\r\nPayments = [0] * N\r\nExpectations = [0] * (N+1)\r\n\r\nfor i in range(N):\r\n    t, p = map(int, input().split())\r\n    Times[i] = t\r\n    Payments[i] = p\r\n    \r\n    for i in range(N-1, -1, -1):\r\n        if i + Times[i] > N:\r\n            Expectations[i] = Expectations[i+1]\r\n        else:\r\n            Expectations[i] = max(Expectations[i+1], Payments[i] + Expectations[i+Times[i]])\r\n\r\nprint(Expectations[0])\r\n```\r\n\r\n\r\n\r\n## 유형2 - 배낭 문제\r\n\r\n- 무게 & 가치\r\n  - 한계 무게 안에서 최대 가치를 얻기\r\n\r\n### 방법1 : 이차원 배열 이용\r\n\r\n- 무게 & 물건을 좌표로 하는 이차원 배열을 사용\r\n  - 각 물건 & 무게에 대해 최대 가치를 저장\r\n\r\n|       | null | 물건1 | 물건2 | 물건3 | ...  | 물건N |\r\n| ----- | ---- | ----- | ----- | ----- | ---- | ----- |\r\n| null  | 0    | 0     | 0     | 0     | 0    | 0     |\r\n| 무게1 | 0    |       |       |       |      |       |\r\n| 무게2 | 0    |       |       |       |      |       |\r\n| 무게3 | 0    |       |       |       |      |       |\r\n| ...   | 0    |       |       |       |      |       |\r\n| 무게K | 0    |       |       |       |      |       |\r\n\r\n```python\r\n# https://www.acmicpc.net/problem/12865\r\n\r\nN, K = map(int, input().split())\r\nobjs = [[0,0]] + [list(map(int, input().split())) for _ in range(N)]\r\ndp = [[0]*(K+1) for _ in range(N+1)]\r\n\r\nfor i in range(1, N+1):\r\n    for j in range(1, K+1):\r\n        if (j < objs[i][0]):\r\n            dp[i][j] = dp[i-1][j]\r\n        else:\r\n            dp[i][j] = max(dp[i-1][j-objs[i][0]]+objs[i][1], dp[i-1][j])\r\n\r\nprint(dp[-1][-1])\r\n```\r\n\r\n### 방법2: 일차원 배열 이용\r\n\r\n- **무게를 중심**으로 메모이제이션 사용\r\n\r\n- 이 경우 무게를 작은 것부터 계산할 경우(j를 증가시키면서 연산), 작은 무게에서 변경된 값이 높은 무게에서 다시 변경되어 중복 계산이 될 수 있다.\r\n- 따라서 큰 무게부터 작은 무게로 내려가면서 계산해야 한다.\r\n\r\n```python\r\n# https://www.acmicpc.net/problem/12865\r\n\r\nN, K = map(int, input().split())\r\nobjs = [[0,0]] + [list(map(int, input().split())) for _ in range(N)]\r\ndp = [0]*(K+1)\r\n\r\nfor i in range(1, N+1):\r\n    for j in range(1, K+1):\r\n        dp[j] = max(dp[j-objs[i][0]]+objs[i][1], dp[j])\r\n\r\nprint(dp[-1])\r\n```\r\n\r\n","documentTitle":"Dynamic Programming 유형","index":[{"type":"type1","data":" Dynamic Programming 유형"},{"type":"type2","data":" 유형1"},{"type":"type2","data":" 유형2 - 배낭 문제"},{"type":"type3","data":" 방법1 : 이차원 배열 이용"},{"type":"type3","data":" 방법2: 일차원 배열 이용"}]},"__N_SSG":true}