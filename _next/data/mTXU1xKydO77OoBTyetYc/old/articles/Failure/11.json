{"pageProps":{"markdown":"# 비동기 처리(@Async)\r\n\r\n비동기 처리를 위해 Async를 사용했다가 다음과 같은 에러를 발견했다.\r\n\r\n```java\r\nERROR o.s.a.i.SimpleAsyncUncaughtExceptionHandler - Unexpected exception occurred invoking async method\r\n```\r\n\r\n\r\n\r\n## 배경\r\n\r\n달력 동기화, 캐싱 데이터 동기화 작업을 비동기로 처리하고 있었다.\r\n\r\n메서드에 @Async 를 붙여서 사용하고 있었는데 어느날 Unexpected exception occurred invoking async method 라는 메시지를 발견했다.\r\n\r\n\r\n\r\n## Async Config\r\n\r\n비동기 작업은 당연하게도 별도의 쓰레드에 할당되어 돌아간다.\r\n만약 Return 타입이 Future가 아니라 void라면 비동기 작업 중인 쓰레드에서 예외가 발생했을 때 호출 쓰레드까지 예외를 전파할 수 없다.\r\n대신 getAsyncUncaughtExceptionHandler() 메서드를 이용해 AsyncUncaughtExceptionHandler 구현 클래스를 가져와서 처리하게 된다.\r\n\r\n나는 이 AsyncUncaughtExceptionHandler를 따로 구현하지 않아 자동으로 **SimpleAsyncUncaughtExceptionHandler** 로 예외를 처리하게 되었는데, 코드는 다음과 같다.\r\n\r\n```java\r\npublic class SimpleAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {\r\n\r\n\tprivate static final Log logger = LogFactory.getLog(SimpleAsyncUncaughtExceptionHandler.class);\r\n\r\n\r\n\t@Override\r\n\tpublic void handleUncaughtException(Throwable ex, Method method, Object... params) {\r\n\t\tif (logger.isErrorEnabled()) {\r\n\t\t\tlogger.error(\"Unexpected exception occurred invoking async method: \" + method, ex);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n```\r\n\r\n내가 읽었던 로그는 여기서 찍힌 로그였다.\r\n\r\n\r\n\r\n이 부분을 해결하기 위해 Async Config에 getAsyncUncaughtExceptionHandler()를 오버라이드해서 직접 만든 CustomAsyncExceptionHandler 로 비동기 예외를 처리하게 만들었다.\r\n\r\n\r\n\r\n### (+) 쓰레드 풀\r\n\r\n또 추가적으로 Async Config를 이용해 쓰레드 풀을 관리할 수 있다.\r\n\r\nConfig를 통해 getAsyncExecutor()를 명시하지 않으면 SimpleAsyncTaskExecutor가 사용되면 새로운 쓰레드를 **생성** 해서 쓰기 때문에 비효율 적이다.\r\n\r\n따라서 쓰레드풀을 사용하는 Executor를 이용하는 게 좋다.","documentTitle":"비동기 처리(@Async)","index":[{"type":"type1","data":" 비동기 처리(@Async)"},{"type":"type2","data":" 배경"},{"type":"type2","data":" Async Config"},{"type":"type3","data":" (+) 쓰레드 풀"}]},"__N_SSG":true}