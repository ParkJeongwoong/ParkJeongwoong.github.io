{"pageProps":{"markdown":"# 완전 탐색 유형 (브루트 포스) + 순열/조합\r\n\r\n> 모든 경우의 수를 탐색\r\n\r\n가장 단순하고 기초적인 방법임과 동시에 생각보다 자주 문제 해결에 도움이 되는 알고리즘이다.\r\n\r\n시간 초과에 대한 리스크가 있지만 생각보다 자주 브루트 포스만으로 문제가 풀리고 빠르게 구현해서 테스트할 수 있다는 장점 때문에 해법에 접근하는 과정에서 첫 시도로 좋은 방법이다.\r\n\r\n(시간 초과가 나면 그 때 접근 방법을 바꾸면 된다. 확실하지 않은 상태에서 더 복잡한 방법으로 시도했다가 보다 간단한 브루트 포스로 바꿔 접근하기는 심적으로 쉽지 않다)\r\n\r\n\r\n\r\n다만 알고리즘 특성상 문제 조건과 탐색하는 범위를 보고 위험하다 싶으면 높은 확률로 시간초과가 나기 때문에 조건을 잘 보고 다른 방식을 찾는 게 좋을 때도 있다.\r\n\r\n\r\n\r\n브루트 포스 문제는 자료 구조에 따라 2가지로 나뉜다.\r\n\r\n1. 선형 구조 -> 순차탐색\r\n\r\n2. 비선형 구조 -> 그래프 (DFS, BFS)\r\n\r\n\r\n\r\n선형 구조는 아래와 같이 반복문을 사용해 값을 하나씩 확인하며 선형적으로 탐색하는 방법이다.\r\n\r\n```python\r\n# https://www.acmicpc.net/problem/1182\r\n\r\nN, S = map(int, input().split())\r\nnumbers = list(map(int, input().split()))\r\nanswer = 0\r\n\r\n# 비트 마스킹을 이용해 숫자 선택의 유무를 표현\r\n# 3개의 숫자를 선택하는 경우의 수 : 001, 010, 011, 100, 101, 110, 111\r\nstandard = 2**(N) -1\r\nfor i in range(1,standard+1): # 경우의 수 대입\r\n    tmp_sum = 0\r\n    number_i = 1 # number를 선택하는 인덱스\r\n\r\n    while i:\r\n        j = i % 2 # 이진법의 오른쪽 0/1부터 확인\r\n        if j:\r\n            tmp_sum += numbers[N-number_i]\r\n        number_i += 1\r\n        i //= 2\r\n    if tmp_sum == S:\r\n        answer += 1\r\n\r\nprint(answer)\r\n```\r\n\r\n선형 구조는 순열/조합과 섞여서 나오는 경우도 많다.\r\n\r\n개인적으로 재귀 함수 대신 복잡하더라도 while문으로 구현하는 것을 선호한다.\r\n\r\n```python\r\n# 순열\r\ndef permutation(arr): # 사전순으로 순열을 찾는 Next Permutation 방법 (첫 arr가 사전순이어야 한다)\r\n        N = len(arr)\r\n        result = [arr[:]]\r\n        \r\n        while True:\r\n            # 1) i값이 i-1값보다 작으면 stop \r\n            i = N-1\r\n            while i>0 and arr[i-1] > arr[i]:\r\n                i -= 1\r\n\r\n            if i == 0: # 4) 내림차순 정렬 완료\r\n                break\r\n\r\n            # 2) j값이 i-1값보다 더 크면 stop\r\n            j = N-1\r\n            while arr[j] < arr[i-1]:\r\n                j -= 1\r\n            arr[j], arr[i-1]= arr[i-1], arr[j]\r\n\r\n            # 3) i부터 끝까지 정렬\r\n            k = N-1\r\n            while i < k:\r\n                arr[i], arr[k] = arr[k], arr[i]\r\n                i += 1\r\n                k -= 1\r\n            \r\n            result.append(arr[:])\r\n\r\n        return result\r\n\r\n\r\n# 조합\r\ndef combination(arr):\r\n    result = []\r\n\r\n    bitmasking = 2**(len(arr))-1\r\n    for bit_num in range(1,bitmasking+1):\r\n        index = 1\r\n        tmp_arr = []\r\n\r\n        while bit_num:\r\n            if bit_num % 2:\r\n                tmp_arr.append(numbers[len(arr)-imdex])\r\n\r\n            index += 1\r\n            bit_num //= 2\r\n\r\n    return result\r\n```\r\n\r\n\r\n\r\n비선형 구조는 백트래킹 같은 기법 없이 DFS와 BFS를 끝까지 진행하는 방식을 말한다.\r\n\r\n```python\r\n# https://www.acmicpc.net/problem/2644\r\n\r\ndef dfs(i,j, level):\r\n    if isSunken(i,j,level) or visited[i][j]:\r\n        return False\r\n\r\n    stack = [(i,j)]\r\n\r\n    while stack:\r\n        y, x = stack.pop()\r\n\r\n        if visited[y][x]:\r\n            continue\r\n        visited[y][x] = True\r\n        if isSunken(y,x,level):\r\n            continue\r\n\r\n        for d in range(4):\r\n            ny = y + dy[d]\r\n            nx = x + dx[d]\r\n            if 0<=ny and ny<N and 0<=nx and nx<N and not visited[ny][nx]:\r\n                stack.append((ny,nx))\r\n\r\n    return True\r\n\r\ndef isSunken(i,j,level):\r\n    if area[i][j] < level:\r\n        return True\r\n\r\n# Run\r\ndy = [0,-1,0,1]\r\ndx = [1,0,-1,0]\r\nN = int(input())\r\narea = []\r\nminHeight = 100\r\nmaxHeight = 1\r\nanswer = 0\r\n\r\nfor _ in range(N):\r\n    tempArea = list(map(int, input().split()))\r\n    minHeight = min(minHeight, min(tempArea))\r\n    maxHeight = max(maxHeight, max(tempArea))\r\n    area.append(tempArea)\r\n\r\nfor level in range(minHeight-1, maxHeight+1):\r\n    visited = [[False]*N for _ in range(N)]\r\n    tempAnswer = 0\r\n    for i in range(N):\r\n        for j in range(N):\r\n            tempAnswer += dfs(i,j, level)\r\n    answer = max(answer, tempAnswer)\r\n\r\nprint(answer)\r\n```\r\n\r\n(그래프 유형은 다음에 작성할 그래프 유형 글에서 더 깊게 다룰 예정)\r\n","documentTitle":"완전 탐색 유형 (브루트 포스) + 순열/조합","index":[{"type":"type1","data":" 완전 탐색 유형 (브루트 포스) + 순열/조합"}]},"__N_SSG":true}