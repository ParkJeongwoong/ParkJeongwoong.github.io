{"pageProps":{"markdown":"# [CleanCode] 함수\r\n\r\n```\r\n출처 : Clean Code - Robert C. Martin\r\n```\r\n\r\n좋은 코드는 글처럼 읽을 수 있는 코드입니다.\r\n\r\n코드를 읽으며 변수명을, 함수를, 클래스를 통해 자연스럽게 내용을 파악할 수 있도록 만드는 것이 중요합니다.\r\n\r\n클린코드의 3장은 좋은 코드를 만들기 위해 함수를 어떻게 만들어야 할지 다음과 같이 이야기합니다.\r\n\r\n\r\n\r\n## 작게 만들기\r\n\r\n> 최대한 짧게\r\n\r\n함수는 작으면 작을수록 좋습니다.\r\n\r\n함수 내에 \"동작\"이라고 불릴만한 것들은 전부 함수로 만들어 짧은 글처럼 읽을 수 있게 만들어야 합니다.\r\n\r\n```java\r\npublic static String renderPageWithSetupsAndTeardowns(\r\n        PageData pageData, boolean isSuite) throws Exception {\r\n    if (isTestPage(pageData))\r\n        includeSetupAndTeardownPages(pageData, isSuite);\r\n    return pageData.getHtml();\r\n }\r\n```\r\n\r\n위의 코드는 FitNesse를 이용한 테스트 관련 코드입니다. (Setup과 Teardown은 Fitness의 테스트에서 페이지의 Header와 Footer입니다)\r\n\r\n모든 기능을 자연스럽게 읽을 수 있는 이름의 함수로 만들어두어 FitNesse에 대한 사전 지식이 있다면 동작 과정을 자연스레 파악할 수 있습니다.\r\n\r\n> 테스트 페이지에 Setup 페이지와 Teardown 페이지를 추가하고 HTML로 렌더링\r\n\r\n\r\n\r\n## 한 가지 일만 하기\r\n\r\n> 추상화 수준 유지\r\n\r\n함수는 한 번에 한 가지 일만 해야 합니다.\r\n\r\n그리고 이를 위해서는 함수 내에서 추상화 수준이 바뀌면 안 됩니다. (함수 내부의 문장은 모두 동일한 추상화 수준을 유지)\r\n\r\n### 사이드 이펙트 없애기\r\n\r\n작은 동작이라도 합의되지 않은(함수의 이름만으로 유추하기 힘든) 기능이 들어가는 것은 오해를 만들 수 있습니다.\r\n\r\n\r\n\r\n## 내려가기 규칙\r\n\r\n> 아래로 갈수록 추상화 수준을 낮추기\r\n\r\n위에서 아래로 갈수록 추상화 수준을 낮추는 것이 읽기 좋습니다.\r\n\r\n즉 위쪽 함수들은 추상화 수준이 높은 함수로 배치하고 아래쪽 함수들은 추상화 수준이 낮은 함수로 배치하는 것이 가독성이 좋아집니다.\r\n\r\n\r\n\r\n## Switch문\r\n\r\n추상 팩토리와 다형성을 사용하여 Switch문이 장황해지는 것을 해결할 수 있다고 합니다.\r\n\r\n> 이 부분은 조금 더 이해를 하고 정리하도록 하겠습니다.\r\n\r\n### 자세한 설명\r\n\r\n```java\r\npublic class Employee {\r\n    String type;\r\n}\r\n```\r\n\r\n```java\r\npublic Money calculatePay(Employee e) throws InvalidEmployeeType {\r\n    switch (e.type) {\r\n        case COMMISSIONED:\r\n            return caclculateCommissionedPay(e);\r\n        case HOURLY:\r\n            return calculateHourlyPay(e);\r\n        case SALARIED:\r\n            return calculateSalariedPay(e);\r\n        default:\r\n            throw new InvalidEmployeeType(e.type);\r\n    }\r\n}\r\n```\r\n\r\n위의 코드의 문제점은 **Employee 클래스에 새로운 type이 추가될 때마다** 끝도없이 calculatePay 함수에 새로운 분기가 생기면서 함수가 늘어진다는 것입니다. 뿐만 아니라 type별로 나눠서 계산해야하는 모든 작업의 switch문마다 새로운 type을 위한 코드 추가를 해야 합니다.\r\n\r\n\r\n\r\n위의 코드는 아래처럼 리팩토링할 수 있습니다.\r\n\r\n```java\r\npublic abstract class Employee {\r\n    public static boolean isPayday();\r\n    public static Money calculatePay();\r\n    public static void deliverPay(Money pay);\r\n}\r\n\r\npublic class CommissionedEmployee extends Employee {\r\n    public static boolean isPayday() {...};\r\n    public static Money calculatePay() {...};\r\n    public static void deliverPay(Money pay) {...};\r\n}\r\npublic class HourlyEmployee extends Employee {\r\n    public static boolean isPayday() {...};\r\n    public static Money calculatePay() {...};\r\n    public static void deliverPay(Money pay) {...};\r\n}\r\npublic class SalariedEmployee extends Employee {\r\n    public static boolean isPayday() {...};\r\n    public static Money calculatePay() {...};\r\n    public static void deliverPay(Money pay) {...};\r\n}\r\n```\r\n\r\n```java\r\npublic interface EmployeeFactory {\r\n    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;\r\n}\r\n\r\npublic class EmployeeFactoryImpl implements EmployeeFactory {\r\n    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {\r\n        switch (r.type) {\r\n            case COMMISSIONED:\r\n                return new CommissionedEmployee(r);\r\n            case HOURLY:\r\n                return new HourlyEmployee(r);\r\n            case SALARIED:\r\n                return new SalariedEmployee(r);\r\n            default:\r\n                throw new InvalidEmployeeType(r.type);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n리팩토링이 된 함수에서는 switch문을 3개(\"isPayday\", \"calculatePay\", \"deliveryPay\")에서 1개(makeEmployee)로 줄였습니다.\r\n\r\n즉 **처음에 객체를 생성할 때만 switch문을 사용**해서 하는 방식으로 switch문에서 파생되는 문제를 줄일 수 있습니다.\r\n\r\n\r\n\r\n## 서술적인 이름\r\n\r\n> 길고 서술적인 이름\r\n\r\n함수의 이름은 짧고 이해하기 어려운 것보다 길고 서술적인 내용을 담은 것이 좋습니다.\r\n\r\n\r\n\r\n## 인수\r\n\r\n> 인수는 최소화\r\n\r\n함수의 인수는 최소화 시키는 것이 좋습니다. (0개가 최고)\r\n\r\n\r\n\r\n**클래스를 활용**해서 인수를 클래스화 시키면 <u>메서드를 통해 인수에 접근</u>하거나 <u>함수의 인수로 클래스를 사용하는 방식</u>을 통해 함수의 인수를 줄일 수 있습니다.\r\n\r\n\r\n\r\n## 예외 사용\r\n\r\n> 오류보다는 예외\r\n\r\nTry Catch가 들어있는 함수, Try에서 동작할 함수, Catch에서 동작할 함수를 분리합니다.\r\n\r\n또한 오류보다는 예외 처리를 하는 것이 코드를 더 깔끔하게 만듭니다.\r\n\r\n\r\n\r\n## 반복 지양\r\n\r\n당연하지만, 반복을 지양합니다.\r\n\r\n\r\n\r\n## 구조적 프로그래밍\r\n\r\n[순차적 - 절차적(구조적) - 객체지향적]으로 이어지는 패러다임 중 구조적 프로그래밍의 법칙인 \"함수의 return은 하나만\", \"break, continue는 금기\"는 함수가 클 때 유용합니다.\r\n\r\n따라서 함수를 작게 만들고자하는 방법론에서는 위의 규칙을 엄격히 지킬 필요가 없습니다.\r\n\r\n\r\n\r\n## 깔끔한 함수를 위한 여정\r\n\r\n처음부터 위의 규칙을 모두 지키는 코드를 만들기는 어렵습니다.\r\n\r\n초안을 쓰고 문장을 다듬는 것처럼, 스케치를 한 뒤 선을 다듬는 것처럼 코드도 처음에는 길고 복잡하게 짜고 나중에 다듬는 방식으로 좋은 코드를 얻어낼 수 있습니다.\r\n","documentTitle":"[CleanCode] 함수","index":[{"type":"type1","data":" [CleanCode] 함수"},{"type":"type2","data":" 작게 만들기"},{"type":"type2","data":" 한 가지 일만 하기"},{"type":"type3","data":" 사이드 이펙트 없애기"},{"type":"type2","data":" 내려가기 규칙"},{"type":"type2","data":" Switch문"},{"type":"type3","data":" 자세한 설명"},{"type":"type2","data":" 서술적인 이름"},{"type":"type2","data":" 인수"},{"type":"type2","data":" 예외 사용"},{"type":"type2","data":" 반복 지양"},{"type":"type2","data":" 구조적 프로그래밍"},{"type":"type2","data":" 깔끔한 함수를 위한 여정"}]},"__N_SSG":true}