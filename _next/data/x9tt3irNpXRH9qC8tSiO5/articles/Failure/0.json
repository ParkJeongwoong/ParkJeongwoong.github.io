{"pageProps":{"markdown_gitHub":"# [Spring Boot 프로젝트] HTTPS 설정 실패\r\n\r\n## 과정\r\n\r\n### Mixed Content\r\n\r\n```\r\n[Github Pages] - [EC2]\r\n```\r\n\r\n**스프링 부트와 AWS로 혼자 구현하는 웹 서비스**를 보고 만든 EC2 WAS를 Github Page로 만든 프론트단과 연결하려고 했다.\r\n\r\n그리고 `Mixed Content` 에러를 마주했다.\r\n\r\n깃헙 페이지는 보안이 적용된 HTTPS 프로토콜을 사용하는데, EC2의 WAS는 HTTP 프로토콜을 사용해서 호환이 되지 않는 문제였다.\r\n\r\n이를 해결하려면 EC2의 WAS를 HTTPS로 변경해야 했다.\r\n\r\n\r\n\r\n### SSL 인증서 오류\r\n\r\n```\r\n[Github Pages] - [ALB] - [EC2]\r\n```\r\n\r\n[freenom](https://www.freenom.com/)을 통해 무료 도메인을 생성하고 이를 AWS에서 제공하는 ACM(SSL 인증서)과 ALB(로드밸런서)를 이용해 HTTPS 프로토콜 세팅을 했더니 다음과 같은 `ERR_CERT_COMMON_NAME_INVALID` 에러가 생겼다.\r\n\r\n![image-20220203213355629](../../../../public/assets/image-20220203213355629.png)\r\n\r\n요청을 보낸 서버 이름과 SSL 인증서의 서버 이름이 달라서 생기는 문제인데, 이를 해결하기 위해 여러 방법을 시도했는데 아직 해결하지 못했다. \r\n\r\n=> SSL 인증서는 도메인 이름으로 만들었기 때문에 EC2로 직접 요청하는 것이 아니라 확보한 도메인으로 요청해야 한다.\r\n\r\n**EC2 서버에 해당 도메인의 SSL을 직접 설치**하면 되지만 사용할 도메인은 기간 제한이 있는 무료 도메인이라 도메인이 바뀌면 인증서를 또 바꿔야 할까 싶어 다른 방법을 찾기로 했다. AWS에서 제공하는 로드밸런서와 SSL 인증서를 이용하면 되지 않을까 싶었다.\r\n\r\n=> **Fail**. 결국 EC2 서버에 직접 SSL 인증서를 설치하기로 함 & 결국 AWS도 곧 유료로 전환될 예정이라 다른 클라우드로 갈아탈 예정\r\n\r\n\r\n\r\n### Nginx\r\n\r\n온갖 방법을 시도해도 문제가 해결되지 않아 Nginx를 이용해서 443포트로 들어오는 HTTPS 연결을 처리하려고 했다.\r\n\r\n처음에 yum install을 이용해 Nginx를 설치하고 openssl을 통해 SSL 인증서를 EC2에 설치한 후 Nginx를 실행하니 HTTP 접속은 가능하나 HTTPS 접속이 되지 않았다.\r\n\r\nhttp_ssl_module을 추가하고자 삭제한 후 이후부터는 Yum을 사용하지 않고 컴파일 설치를 시도했는데 각종 (2 no such file or directory) 에러, (21: Is a directory) 에러 등이 떠 10번 가까이 삭제와 재설치를 반복했다.\r\n\r\n덕분에 Nginx 설치, 환경설정은 어느정도 익숙해졌지만 결국 아직까지 해결하지 못했다.\r\n\r\n![image-20220206162718748](../../../../public/assets/image-20220206162718748.png)\r\n\r\n\r\n\r\nyum과 certbot을 이용해 시도를 해봐야겠다.\r\n\r\n\r\n\r\n#### yum install nginx\r\n\r\n결국 컴파일 설치를 포기하고 다시 yum install nginx를 통해 설치를 했다.\r\n\r\nservice nginx start를 하니 다음과 같은 **status=203/EXEC** 에러가 떴다.\r\n\r\n![image-20220208000908494](../../../../public/assets/image-20220208000908494.png)\r\n\r\n확인해보니 이전 컴파일 설치를 하면서 nginx.service 파일 설정을 수정했던 게 남아있어서 start 명령을 잘못 잡은 것이었다. sbin 디렉토리의 nginx를 실행시키니 잘 돌아갔고 nginx.service 파일의 세팅값을 현재 상태에 맞게 수정하니 nginx가 돌아갔다.\r\n\r\n\r\n\r\n## HTTPS 적용 성공\r\n\r\nhttps://kerobero.tistory.com/40\r\n\r\n위의 블로그를 참고하여 HTTPS 설정을 완료할 수 있었다.\r\n\r\n![image-20220208015124131](../../../../public/assets/image-20220208015124131.png)\r\n\r\n(HTTP)\r\n\r\n![image-20220208015101387](../../../../public/assets/image-20220208015101387.png)\r\n\r\n(HTTPS)\r\n\r\n\r\n\r\nNginx는 yum으로 설치했으며,\r\n\r\nEpel은 amazon-linux-extras로 설치했다. (이걸 설치해야 certbot이 설치됐으며 yum install epel-release를 사용하니 amazon-linux-extras을 사용해 epel이란 이름으로 설치하라는 메시지가 나왔다)\r\n\r\ncertbot은 yum으로 설치했다.\r\n\r\n이후 **certbot certonly --standalone -d [도메인]** 명령어로 SSL 인증서를 받고 (자동으로 /etc/letsencrypt/live/ 디렉토리에 설정한 도메인으로 디렉토리가 하나 더 생기고 그 안에 pem 키가 들어있다) 이를 config 파일의 443번 포트에 적용했다.\r\n\r\n\r\n\r\n이렇게 간단히 할 수 있는 걸 잘 모르는 상태에서 컴파일 설치를 하려고 이것저것 만지는 바람에 너무 오래 걸렸다. 그래도 삽질하면서 설정파일을 계속 오가며 수정한 덕분에 리눅스가 조금 더 익숙해졌다.\r\n\r\n\r\n\r\n### 포트 포워딩\r\n\r\n80번, 443번 포트로 접속해도 8080포트로 연결되도록 nginx.conf 파일의 server-loaction 부분을 다음과 같이 수정했다.\r\n\r\n```yaml\r\n# 출처 : https://steady-hello.tistory.com/46\r\n\r\nserver {\r\n    listen       443 ssl;\r\n    server_name  localhost;\r\n\r\n    ssl_certificate /etc/letsencrypt/live/dvlprjw.kro.kr/fullchain.pem;\r\n    ssl_certificate_key /etc/letsencrypt/live/dvlprjw.kro.kr/privkey.pem;\r\n\r\n\tlocation / {\r\n        # 변경한 부분\r\n        proxy_pass http://localhost:8080;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_Add_X_forwarded_for;\r\n        proxy_set_header Host $http_host;\r\n        # 변경한 부분\r\n    }\r\n\r\n    #error_page  404              /404.html;\r\n    error_page   500 502 503 504  /50x.html;\r\n    location = /50x.html {\r\n        root   /usr/share/nginx/html;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## CORS\r\n\r\n현재 이루어지고 있는 통신은 다음과 같다.\r\n\r\n> [Client] ----- [github.io] ----- [AWS]\r\n\r\n이렇게 클라이언트는 github 페이지에 접속했는데, 요청을 AWS로 보냈기 때문에 CORS가 발생했다.\r\n\r\n\r\n\r\nCORS는 Response Header의 Access-Control-Allow-Origin에 허용할 요청의 주소를 넣어 해결할 수 있다.\r\n\r\n따라서 Spring-boot의 WebConfig.java 파일에 다음 코드를 추가함으로써 해결했다.\r\n\r\n```java\r\n@RequiredArgsConstructor\r\n@Configuration\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    private final LoginUserArgumentResolver loginUserArgumentResolver;\r\n\r\n    @Override\r\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\r\n        argumentResolvers.add(loginUserArgumentResolver);\r\n    }\r\n\r\n    @Override\r\n    public void addCorsMappings(CorsRegistry registry) {\r\n        registry.addMapping(\"/**\")\r\n                .allowedOrigins(\"http://localhost:3000\", \"https://parkjeongwoong.github.io\");\r\n    }\r\n}\r\n```\r\n\r\n","documentTitle":"[Spring Boot 프로젝트] HTTPS 설정 실패","articleCategory":"Failure","articleId":"0"},"__N_SSG":true}