<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Data Link Control | 웅&#x27;s 블로그</title><meta name="description" content="http://www.kocw.net/home/search/kemView.do?kemId=299067

# Data Link Control

&gt; framing, flow control, error control, protocols

라우터 : 신호를 다른 컴퓨터로 연결하는 장치 (일종의 컴퓨터)

=&gt; End System(실제 우리가 다루는 컴퓨터) 사이에 전송되는 Data를 관리하는 기술이 `Data Link Control`



## Data Link Layer의 역할

- Frame synchronization
  	Frame: 데이터 덩어리 / Data는 여러 조각(blcoks)으로 분리해서 보낸다
  	그리고 보내는 쪽과 받는 쪽은 이 데이터 조각이 동기화가 돼야 한다

- Flow control
  	receiver가 sender의 data를 통제하는 것 (너무 많은 데이터가 한 번에 오지 않도록)

- **Error control** (굉장히 중요)

  ​	통신 중 발생하는 error를 조정하는 것

- Physical addressing

  ​	통신을 할 대상을 특정하는 물리적 주소 (식별자)

- Access control

  ​	여러 장치가 같은 link에 연결되어 있을 때, 어떤 장치가 연결될 지 결정하는 것

### 결론

- Data Link Layer의 역할
  1. `Line discipline` (access control) - 누가?
  2. `flow control` - 얼마나 많이?
  3. **`error control` - detect, correct errors**



## Poll / Select

`multidrop`(=`multipoint`)를 사용하면 transmission line costs를 줄일 수 있다

​	=&gt; 여러 터미널이 선 하나를 공유하는 것

- 이 때 &lt;u&gt;한 번에 message block 하나&lt;/u&gt;만 보낼 수 있다.

  =&gt; 지금은 많이 사용하지 않는 방식

  [Primary computer와 Secondary computer로 나뉘던 옛날 컴퓨터에서 많이 사용]

  - `Polling`: secondary가 send할 때 사용
    - `Roll-call Polling`: primary가 하나씩 다 물어보는 것
    - `Hub Polling`: poll command를 secondary에게 주고 secondary가 서로 command를 돌리며 poll을 결정하는 것 
  - `Select`: primary가 send할 때 사용



## Framing

&gt; Data Link Layer는 bits를 frame에 넣어 보낸다 =&gt; 각각 구분될 수 있는 frame에 넣음으로 써 data를 구분

만약 message가 매우 큰 frame 하나에 담겨져 보내진다면 하나의 error가 전체 데이터에 큰 영향을 끼침

(Error가 발생하면 해당 frame을 재전송하는데, frame이 크면 error가 발생할 때마다 큰 데이터를 다시 받아와야 함)

"/><meta property="og:type" content="website"/><meta property="og:title" content="Data Link Control"/><meta property="og:description" content="http://www.kocw.net/home/search/kemView.do?kemId=299067

# Data Link Control

&gt; framing, flow control, error control, protocols

라우터 : 신호를 다른 컴퓨터로 연결하는 장치 (일종의 컴퓨터)

=&gt; End System(실제 우리가 다루는 컴퓨터) 사이에 전송되는 Data를 관리하는 기술이 `Data Link Control`



## Data Link Layer의 역할

- Frame synchronization
  	Frame: 데이터 덩어리 / Data는 여러 조각(blcoks)으로 분리해서 보낸다
  	그리고 보내는 쪽과 받는 쪽은 이 데이터 조각이 동기화가 돼야 한다

- Flow control
  	receiver가 sender의 data를 통제하는 것 (너무 많은 데이터가 한 번에 오지 않도록)

- **Error control** (굉장히 중요)

  ​	통신 중 발생하는 error를 조정하는 것

- Physical addressing

  ​	통신을 할 대상을 특정하는 물리적 주소 (식별자)

- Access control

  ​	여러 장치가 같은 link에 연결되어 있을 때, 어떤 장치가 연결될 지 결정하는 것

### 결론

- Data Link Layer의 역할
  1. `Line discipline` (access control) - 누가?
  2. `flow control` - 얼마나 많이?
  3. **`error control` - detect, correct errors**



## Poll / Select

`multidrop`(=`multipoint`)를 사용하면 transmission line costs를 줄일 수 있다

​	=&gt; 여러 터미널이 선 하나를 공유하는 것

- 이 때 &lt;u&gt;한 번에 message block 하나&lt;/u&gt;만 보낼 수 있다.

  =&gt; 지금은 많이 사용하지 않는 방식

  [Primary computer와 Secondary computer로 나뉘던 옛날 컴퓨터에서 많이 사용]

  - `Polling`: secondary가 send할 때 사용
    - `Roll-call Polling`: primary가 하나씩 다 물어보는 것
    - `Hub Polling`: poll command를 secondary에게 주고 secondary가 서로 command를 돌리며 poll을 결정하는 것 
  - `Select`: primary가 send할 때 사용



## Framing

&gt; Data Link Layer는 bits를 frame에 넣어 보낸다 =&gt; 각각 구분될 수 있는 frame에 넣음으로 써 data를 구분

만약 message가 매우 큰 frame 하나에 담겨져 보내진다면 하나의 error가 전체 데이터에 큰 영향을 끼침

(Error가 발생하면 해당 frame을 재전송하는데, frame이 크면 error가 발생할 때마다 큰 데이터를 다시 받아와야 함)

"/><meta property="og:site_name" content="웅&#x27;s 블로그"/><link rel="icon" href="/myLogo_transp.png"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-90a60b87fd0d5fc150f2.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5c5e9ad3fe84116dc753.js" defer=""></script><script src="/_next/static/chunks/485-1121db7a55400d486874.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5BarticleCategory%5D/%5BarticleId%5D-0ecc19cf66a78d7522c3.js" defer=""></script><script src="/_next/static/gAf4ydhT9QSG4g_QmYQsE/_buildManifest.js" defer=""></script><script src="/_next/static/gAf4ydhT9QSG4g_QmYQsE/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App"><div class="App__Content"><div class="Header_Header__1J9sN"><div class="Header_Header__styling__U361E"><img src="/myLogo_transp.png" alt="logo"/></div><a class="Header_Header__word__hqgKV" href="/">Home</a><a class="Header_Header__word__hqgKV" href="/profile">Profile</a><a class="Header_Header__word__hqgKV" href="/articles">Articles</a><a class="Header_Header__word__hqgKV" href="/archives">Archives</a><div class="Header_Header__styling_Reverse__2G1sc"></div></div><div><main><div class="globalStyles_loader__29zgS"><span>Loading...</span></div></main></div></div><div class="Footer_Footer__16BK3"><div class="Footer_Footer__github__3FRw-">Github : <a href="https://github.com/ParkJeongwoong">ParkJeongwoong</a></div><div class="Footer_Footer__email__gbWyz">Contact : <span>dvlprjw@gmail.com</span></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdown":"http://www.kocw.net/home/search/kemView.do?kemId=299067\r\n\r\n# Data Link Control\r\n\r\n\u003e framing, flow control, error control, protocols\r\n\r\n라우터 : 신호를 다른 컴퓨터로 연결하는 장치 (일종의 컴퓨터)\r\n\r\n=\u003e End System(실제 우리가 다루는 컴퓨터) 사이에 전송되는 Data를 관리하는 기술이 `Data Link Control`\r\n\r\n\r\n\r\n## Data Link Layer의 역할\r\n\r\n- Frame synchronization\r\n  \tFrame: 데이터 덩어리 / Data는 여러 조각(blcoks)으로 분리해서 보낸다\r\n  \t그리고 보내는 쪽과 받는 쪽은 이 데이터 조각이 동기화가 돼야 한다\r\n\r\n- Flow control\r\n  \treceiver가 sender의 data를 통제하는 것 (너무 많은 데이터가 한 번에 오지 않도록)\r\n\r\n- **Error control** (굉장히 중요)\r\n\r\n  ​\t통신 중 발생하는 error를 조정하는 것\r\n\r\n- Physical addressing\r\n\r\n  ​\t통신을 할 대상을 특정하는 물리적 주소 (식별자)\r\n\r\n- Access control\r\n\r\n  ​\t여러 장치가 같은 link에 연결되어 있을 때, 어떤 장치가 연결될 지 결정하는 것\r\n\r\n### 결론\r\n\r\n- Data Link Layer의 역할\r\n  1. `Line discipline` (access control) - 누가?\r\n  2. `flow control` - 얼마나 많이?\r\n  3. **`error control` - detect, correct errors**\r\n\r\n\r\n\r\n## Poll / Select\r\n\r\n`multidrop`(=`multipoint`)를 사용하면 transmission line costs를 줄일 수 있다\r\n\r\n​\t=\u003e 여러 터미널이 선 하나를 공유하는 것\r\n\r\n- 이 때 \u003cu\u003e한 번에 message block 하나\u003c/u\u003e만 보낼 수 있다.\r\n\r\n  =\u003e 지금은 많이 사용하지 않는 방식\r\n\r\n  [Primary computer와 Secondary computer로 나뉘던 옛날 컴퓨터에서 많이 사용]\r\n\r\n  - `Polling`: secondary가 send할 때 사용\r\n    - `Roll-call Polling`: primary가 하나씩 다 물어보는 것\r\n    - `Hub Polling`: poll command를 secondary에게 주고 secondary가 서로 command를 돌리며 poll을 결정하는 것 \r\n  - `Select`: primary가 send할 때 사용\r\n\r\n\r\n\r\n## Framing\r\n\r\n\u003e Data Link Layer는 bits를 frame에 넣어 보낸다 =\u003e 각각 구분될 수 있는 frame에 넣음으로 써 data를 구분\r\n\r\n만약 message가 매우 큰 frame 하나에 담겨져 보내진다면 하나의 error가 전체 데이터에 큰 영향을 끼침\r\n\r\n(Error가 발생하면 해당 frame을 재전송하는데, frame이 크면 error가 발생할 때마다 큰 데이터를 다시 받아와야 함)\r\n\r\n","documentTitle":"Data Link Control"},"__N_SSG":true},"page":"/articles/[articleCategory]/[articleId]","query":{"articleCategory":"CS","articleId":"0"},"buildId":"gAf4ydhT9QSG4g_QmYQsE","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>