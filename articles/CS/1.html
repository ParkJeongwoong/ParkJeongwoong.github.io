<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>High-level Data Link Control (HDLC) | 웅&#x27;s 블로그</title><meta name="description" content="http://www.kocw.net/home/search/kemView.do?kemId=299067

# High-level Data Link Control (HDLC)

Data Link Control을 지원하는 Protocol은 2가지가 있음

1. **Character-oriented protocol** (=Byte-oriented protocol)
2. **Bit-oriented protocol**

데이터를 잘게 쪼갠 것 = Frame -&gt; 이 Frame을 Bit 단위로 쪼개 볼거냐, Byte 단위로 쪼개 볼 거냐를 구분 짓는 게 위 2개의 protocol



## Character-oriented protocols

&gt; Frame을 문자(혹은 byte)의 나열로 해석하는 것
&gt;
&gt; 1 Character = 8bit = 1byte

- 현재는 많이 사용하지 않음
  - 대부분 Bit-oriented protocol 사용



❗ 구조

[Flag]&lt;Header&gt; `[Characters]` &lt;Trailer&gt;[Flag]

&gt; Flag : Frame의 시작과 끝을 구분지음
&gt;
&gt; Header, Trailer : Data 외의 추가적인 정보



❓만약 Data에 Flag 신호와 똑같은 Byte가 들어간다면..??

[`투명성 문제`] (Transparency Problem)

- **byte-stuffing**

  이를 해결하기 위해 `escape character (ESC)`를 추가한다

  - ESC를 넣는 위치
    1. **Flag와 동일**한 신호 앞
    2. **ESC와 동일**한 신호 앞



## Bit-oriented protocols

&gt; Frame을 bit의 나열로 해석하는 것

- 오늘날 대부분의 경우 사용하는 protocol

- 대부분의 protocol을 **`01111110`**이라는 8-bit pattern을 flag로 사용



❗ 구조

[01111110] &lt;Header&gt; `[Bits]` &lt;Trailer&gt; [01111110]



❓만약 Data에 Flag 신호와 똑같은 Bit가 들어간다면..??

- **Bit-stuffing**

  data에 1이 연속으로 6개가 나오는 것을 방지하기 위해

  **1이 5개가 연속으로 나오면 extra 0를 붙인다**



---

## Flow and Error Control

### Flow control

&gt; 수신자 측에서, 데이터의 양을 조절하는 것

- `acknowledgement`를 이용해 제어

- 기법
  1. **XON/XOFF** : Start or Stop transmission
  2. **Stop-and-wait** : send &lt;u&gt;one frame&lt;/u&gt; at a time
  3. **Sliding window** : send &lt;u&gt;several frames&lt;/u&gt; at a time



#### XON/XOFF

&gt; Serial terminal에서 많이 사용됨 (프린터, 복사기 등)

- 더 이상 데이터를 받을 수 없을 때 Xoff 신호를 보냄 / *프린터의 메모리(버퍼)가 어느정도 차면 신호를 보냄*

- 다시 작업이 가능해지면 Xon 신호를 보냄



#### Stop-and-wait

- 한 번에 **하나의 frame**을 보냄 -&gt; 잘 받으면 **acknowledgment**를 회신 -&gt; 다시 한 **frame** 송신
- 간단하다는 장점 / 비효율적이라는 단점



#### Sliding window

- **Window size** : 한 번에 보내는 frame의 개수 = **# of outstanding frame**(=unacknowledged frame)
- frame의 Header 부분에 frame 번호가 들어감 (보통 3비트를 사용)



- 한 번에 **여러 개의 frame**을 보냄 (window size 만큼) -&gt; **acknowledgment**를 회신 -&gt; **window size 갱신** -&gt; 다시 **frame** 송신



### Error Control

- 받은 데이터가 손상되었는지 확인, 복원
  1. Error Detection
  2. Error Correction

- 기법
  1. **Discarding the errors** : 무시 (복구 X), 꽤 많이 씀
  2. **Forward Error Correction (FEC)** : 수신 측에서 Error **복구**
  3. **Automatic repeat request (ARQ)** : 가장 많이 사용됨. Error 발생시 **재전송**



- Error의 종류
  - frame의 소실 (도착 X)
  - frame의 손상"/><meta property="og:type" content="website"/><meta property="og:title" content="High-level Data Link Control (HDLC)"/><meta property="og:description" content="http://www.kocw.net/home/search/kemView.do?kemId=299067

# High-level Data Link Control (HDLC)

Data Link Control을 지원하는 Protocol은 2가지가 있음

1. **Character-oriented protocol** (=Byte-oriented protocol)
2. **Bit-oriented protocol**

데이터를 잘게 쪼갠 것 = Frame -&gt; 이 Frame을 Bit 단위로 쪼개 볼거냐, Byte 단위로 쪼개 볼 거냐를 구분 짓는 게 위 2개의 protocol



## Character-oriented protocols

&gt; Frame을 문자(혹은 byte)의 나열로 해석하는 것
&gt;
&gt; 1 Character = 8bit = 1byte

- 현재는 많이 사용하지 않음
  - 대부분 Bit-oriented protocol 사용



❗ 구조

[Flag]&lt;Header&gt; `[Characters]` &lt;Trailer&gt;[Flag]

&gt; Flag : Frame의 시작과 끝을 구분지음
&gt;
&gt; Header, Trailer : Data 외의 추가적인 정보



❓만약 Data에 Flag 신호와 똑같은 Byte가 들어간다면..??

[`투명성 문제`] (Transparency Problem)

- **byte-stuffing**

  이를 해결하기 위해 `escape character (ESC)`를 추가한다

  - ESC를 넣는 위치
    1. **Flag와 동일**한 신호 앞
    2. **ESC와 동일**한 신호 앞



## Bit-oriented protocols

&gt; Frame을 bit의 나열로 해석하는 것

- 오늘날 대부분의 경우 사용하는 protocol

- 대부분의 protocol을 **`01111110`**이라는 8-bit pattern을 flag로 사용



❗ 구조

[01111110] &lt;Header&gt; `[Bits]` &lt;Trailer&gt; [01111110]



❓만약 Data에 Flag 신호와 똑같은 Bit가 들어간다면..??

- **Bit-stuffing**

  data에 1이 연속으로 6개가 나오는 것을 방지하기 위해

  **1이 5개가 연속으로 나오면 extra 0를 붙인다**



---

## Flow and Error Control

### Flow control

&gt; 수신자 측에서, 데이터의 양을 조절하는 것

- `acknowledgement`를 이용해 제어

- 기법
  1. **XON/XOFF** : Start or Stop transmission
  2. **Stop-and-wait** : send &lt;u&gt;one frame&lt;/u&gt; at a time
  3. **Sliding window** : send &lt;u&gt;several frames&lt;/u&gt; at a time



#### XON/XOFF

&gt; Serial terminal에서 많이 사용됨 (프린터, 복사기 등)

- 더 이상 데이터를 받을 수 없을 때 Xoff 신호를 보냄 / *프린터의 메모리(버퍼)가 어느정도 차면 신호를 보냄*

- 다시 작업이 가능해지면 Xon 신호를 보냄



#### Stop-and-wait

- 한 번에 **하나의 frame**을 보냄 -&gt; 잘 받으면 **acknowledgment**를 회신 -&gt; 다시 한 **frame** 송신
- 간단하다는 장점 / 비효율적이라는 단점



#### Sliding window

- **Window size** : 한 번에 보내는 frame의 개수 = **# of outstanding frame**(=unacknowledged frame)
- frame의 Header 부분에 frame 번호가 들어감 (보통 3비트를 사용)



- 한 번에 **여러 개의 frame**을 보냄 (window size 만큼) -&gt; **acknowledgment**를 회신 -&gt; **window size 갱신** -&gt; 다시 **frame** 송신



### Error Control

- 받은 데이터가 손상되었는지 확인, 복원
  1. Error Detection
  2. Error Correction

- 기법
  1. **Discarding the errors** : 무시 (복구 X), 꽤 많이 씀
  2. **Forward Error Correction (FEC)** : 수신 측에서 Error **복구**
  3. **Automatic repeat request (ARQ)** : 가장 많이 사용됨. Error 발생시 **재전송**



- Error의 종류
  - frame의 소실 (도착 X)
  - frame의 손상"/><meta property="og:site_name" content="웅&#x27;s 블로그"/><link rel="icon" href="/myLogo_transp.png"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-90a60b87fd0d5fc150f2.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9597e0c31f58e932da95.js" defer=""></script><script src="/_next/static/chunks/485-1121db7a55400d486874.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5BarticleCategory%5D/%5BarticleId%5D-0ecc19cf66a78d7522c3.js" defer=""></script><script src="/_next/static/eaNmtN4bgndljZ58tGteQ/_buildManifest.js" defer=""></script><script src="/_next/static/eaNmtN4bgndljZ58tGteQ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App"><div class="App__Content"><div class="Header_Header__1J9sN"><div class="Header_Header__styling__U361E"><img src="/myLogo_transp.png" alt="logo"/></div><a class="Header_Header__word__hqgKV" href="/">Home</a><a class="Header_Header__word__hqgKV" href="/profile">Profile</a><a class="Header_Header__word__hqgKV" href="/articles">Articles</a><a class="Header_Header__word__hqgKV" href="/archives">Archives</a><div class="Header_Header__styling_Reverse__2G1sc"></div></div><div><main><div class="globalStyles_loader__29zgS"><span>Loading...</span></div></main></div></div><div class="Footer_Footer__16BK3"><div class="Footer_Footer__github__3FRw-">Github : <a href="https://github.com/ParkJeongwoong">ParkJeongwoong</a></div><div class="Footer_Footer__email__gbWyz">Contact : <span>dvlprjw@gmail.com</span></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdown":"http://www.kocw.net/home/search/kemView.do?kemId=299067\r\n\r\n# High-level Data Link Control (HDLC)\r\n\r\nData Link Control을 지원하는 Protocol은 2가지가 있음\r\n\r\n1. **Character-oriented protocol** (=Byte-oriented protocol)\r\n2. **Bit-oriented protocol**\r\n\r\n데이터를 잘게 쪼갠 것 = Frame -\u003e 이 Frame을 Bit 단위로 쪼개 볼거냐, Byte 단위로 쪼개 볼 거냐를 구분 짓는 게 위 2개의 protocol\r\n\r\n\r\n\r\n## Character-oriented protocols\r\n\r\n\u003e Frame을 문자(혹은 byte)의 나열로 해석하는 것\r\n\u003e\r\n\u003e 1 Character = 8bit = 1byte\r\n\r\n- 현재는 많이 사용하지 않음\r\n  - 대부분 Bit-oriented protocol 사용\r\n\r\n\r\n\r\n❗ 구조\r\n\r\n[Flag]\u003cHeader\u003e `[Characters]` \u003cTrailer\u003e[Flag]\r\n\r\n\u003e Flag : Frame의 시작과 끝을 구분지음\r\n\u003e\r\n\u003e Header, Trailer : Data 외의 추가적인 정보\r\n\r\n\r\n\r\n❓만약 Data에 Flag 신호와 똑같은 Byte가 들어간다면..??\r\n\r\n[`투명성 문제`] (Transparency Problem)\r\n\r\n- **byte-stuffing**\r\n\r\n  이를 해결하기 위해 `escape character (ESC)`를 추가한다\r\n\r\n  - ESC를 넣는 위치\r\n    1. **Flag와 동일**한 신호 앞\r\n    2. **ESC와 동일**한 신호 앞\r\n\r\n\r\n\r\n## Bit-oriented protocols\r\n\r\n\u003e Frame을 bit의 나열로 해석하는 것\r\n\r\n- 오늘날 대부분의 경우 사용하는 protocol\r\n\r\n- 대부분의 protocol을 **`01111110`**이라는 8-bit pattern을 flag로 사용\r\n\r\n\r\n\r\n❗ 구조\r\n\r\n[01111110] \u003cHeader\u003e `[Bits]` \u003cTrailer\u003e [01111110]\r\n\r\n\r\n\r\n❓만약 Data에 Flag 신호와 똑같은 Bit가 들어간다면..??\r\n\r\n- **Bit-stuffing**\r\n\r\n  data에 1이 연속으로 6개가 나오는 것을 방지하기 위해\r\n\r\n  **1이 5개가 연속으로 나오면 extra 0를 붙인다**\r\n\r\n\r\n\r\n---\r\n\r\n## Flow and Error Control\r\n\r\n### Flow control\r\n\r\n\u003e 수신자 측에서, 데이터의 양을 조절하는 것\r\n\r\n- `acknowledgement`를 이용해 제어\r\n\r\n- 기법\r\n  1. **XON/XOFF** : Start or Stop transmission\r\n  2. **Stop-and-wait** : send \u003cu\u003eone frame\u003c/u\u003e at a time\r\n  3. **Sliding window** : send \u003cu\u003eseveral frames\u003c/u\u003e at a time\r\n\r\n\r\n\r\n#### XON/XOFF\r\n\r\n\u003e Serial terminal에서 많이 사용됨 (프린터, 복사기 등)\r\n\r\n- 더 이상 데이터를 받을 수 없을 때 Xoff 신호를 보냄 / *프린터의 메모리(버퍼)가 어느정도 차면 신호를 보냄*\r\n\r\n- 다시 작업이 가능해지면 Xon 신호를 보냄\r\n\r\n\r\n\r\n#### Stop-and-wait\r\n\r\n- 한 번에 **하나의 frame**을 보냄 -\u003e 잘 받으면 **acknowledgment**를 회신 -\u003e 다시 한 **frame** 송신\r\n- 간단하다는 장점 / 비효율적이라는 단점\r\n\r\n\r\n\r\n#### Sliding window\r\n\r\n- **Window size** : 한 번에 보내는 frame의 개수 = **# of outstanding frame**(=unacknowledged frame)\r\n- frame의 Header 부분에 frame 번호가 들어감 (보통 3비트를 사용)\r\n\r\n\r\n\r\n- 한 번에 **여러 개의 frame**을 보냄 (window size 만큼) -\u003e **acknowledgment**를 회신 -\u003e **window size 갱신** -\u003e 다시 **frame** 송신\r\n\r\n\r\n\r\n### Error Control\r\n\r\n- 받은 데이터가 손상되었는지 확인, 복원\r\n  1. Error Detection\r\n  2. Error Correction\r\n\r\n- 기법\r\n  1. **Discarding the errors** : 무시 (복구 X), 꽤 많이 씀\r\n  2. **Forward Error Correction (FEC)** : 수신 측에서 Error **복구**\r\n  3. **Automatic repeat request (ARQ)** : 가장 많이 사용됨. Error 발생시 **재전송**\r\n\r\n\r\n\r\n- Error의 종류\r\n  - frame의 소실 (도착 X)\r\n  - frame의 손상","documentTitle":"High-level Data Link Control (HDLC)"},"__N_SSG":true},"page":"/articles/[articleCategory]/[articleId]","query":{"articleCategory":"CS","articleId":"1"},"buildId":"eaNmtN4bgndljZ58tGteQ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>