<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>[GitHub Blog 개발기] Markdown 적용 및 Require 함수 | 웅&#x27;s 블로그</title><meta name="description" content="# [GitHub Blog 개발기] Markdown 적용 및 Require 함수

자주 업데이트 되는 Articles 항목은 Markdown으로 작성하기로 결정했다.



Local에 있는 Markdown 파일을 화면에 출력하는 방법은 다음과 같다.



## 1. Markdown 파일을 &lt;u&gt;가져오기&lt;/u&gt;

&gt; [요약]
&gt;
&gt; - JavaScript의 Require 함수를 이용해서 Local에 있는 Markdown 파일의 내용을 저장



**Local에 있는 Markdown 파일을 가져오기 위해서 JavaScript의 Require 함수를 사용했다.**



### JavaScript `Require`

**Require()** : &lt;u&gt;모듈을 가져오는 함수&lt;/u&gt; (정확히는 Modules의 exports를 가져오는 함수)

=&gt; 이 Require()를 이용해서 `Markdown 파일의 Text 정보`를 가져올 수 있다.



#### 순서 1

`require()`를 통해 content data에 담겨있는 path 정보를 이용해서 파일의 정보를 가져온다.

```javascript
const readmePath = require(`store/article_data/${path.split(&quot;/&quot;)[2]}/${
      path.split(&quot;/&quot;)[3]
    }`);
```



#### 순서 2

`fetch() - then() - text()` 과정을 통해 text 정보를 읽는다.

```javascript
fetch(readmePath.default)
    .then(r =&gt; r.text())
    .then(text =&gt; {
      setMarkdown(text);
    });
```



#### Require란?

만약 Javascript 파일을 읽는다면 exports 정보들을, **.default** 를 이용하면 default 값을, **.변수** 를 이용하면 해당 파일에서 exports 된 변수 값을 읽을 수 있다.



Import와 상당히 유사하다.

그렇다면 차이점은 무엇일까?

- require()
  - node.js문
  - 어디서나 호출 가능
  - 파일 전체를 사용



- import()
  - ES6문
  - 시작 부분에서만 호출 가능
  - 필요한 부분만 선택 가능 =&gt; &lt;u&gt;성능이 우수하고 메모리를 절약&lt;/u&gt;



=&gt; 그럼 import가 성능이 더 좋은데 왜 require를 썼는가?

**import는 최상단에서만 호출 가능하여 조건문에 따라 호출이 불가능 하기 때문**





## 2. Markdown 형식으로 &lt;u&gt;출력하기&lt;/u&gt;

&gt; [요약]
&gt;
&gt; - react-markdown 을 사용
&gt; - markdown -&gt; html 으로 변환된 코드에 대한 styling
&gt; - JavaScript를 변화시켜 줌으로써 추가 styling



### react-markdown

#### 설치

먼저 React에서Markdown 형식으로 출력을 시켜줄 `react-markdown`을 설치 (공식문서 : https://www.npmjs.com/package/react-markdown)

```bash
npm install react-markdown
```



#### 사용

(위에서 setMarkdown(text)으로 저장한 markdown 변수를 markdown으로 출력하는 방법)

**`&lt;ReactMarkdown&gt; 태그를 Return 함으로써 출력`**

```react
&lt;ReactMarkdown children={markdown} /&gt;
```



이렇게만 해도 어느정도 Markdown 형태가 잡힌다.



**하지만! &lt;u&gt;이렇게 두면 엉망진창의 예쁘지 않은 글이 된다&lt;/u&gt;**



그럼 입맛대로 꾸미는 법을 알아보자!



### remark-gfm

#### 설치

공식문서에 소개된 것처럼 `remark-gfm`을 설치하면 link, table, checklist 등의 형식을 표현할 수 있다.

```bash
npm install remark-gfm
```



#### 사용

ReactMarkdown 태그 안에 Plugin 형태로 추가하면 끝!

```react
&lt;ReactMarkdown remarkPlugins={[remarkGfm]} children={markdown} /&gt;



### 커스터마이즈 (react-syntax-highlighter)

강조 표시, 인용 표시, 코드 인용을 위해서는 추가적인 작업이 필요하다.

#### 설치

그 중 코드 인용은 `react-syntax-highlighter`를 통해 표시가 가능하다.

​```bash
npm install react-syntax-highlighter
```



#### 사용

1. 먼저 components 속성을 ReactMardown 태그 안에 추가한다.
2. 수정하고 싶은 태그를 적고 수정된 결과물을 return에 넣는다.

```react
&lt;ReactMarkdown remarkPlugins={[remarkGfm]} children={markdown}
    components={
        %%%수정할 태그%%%({ node, inline, className, children, ...props }) { return %%%수정된 태그%%% }
    }
    /&gt;
```

&gt;  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**
&gt;
&gt; **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**
&gt;
&gt; ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )



위 components 속성은 다음과 같이 작동한다.

1. ReactMarkdown이 html화 시킨 코드를 하나씩 읽는다.
2. components 안에 속하는 태그를 찾는다.
3. **조건문**을 통해 커스텀을 하는 조건을 선택한다.
4. 조건을 만족했을 때 **수정된 태그** 를 반환한다.



#### 예시

- `인용 표시`

인용문은 &lt;blockquote&gt; 형태로 출력되기 때문에 인용문을 바꾸고 싶다면 다음과 같이 적으면 된다.

```react
components={
            // 인용문
            blockquote({ node, children, ...props }) {
                return (
                  &lt;div
                    style={{
                      background: &quot;#f0f0f0&quot;,
                      padding: &quot;1px 15px&quot;,
                      borderRadius: &quot;10px&quot;,
                    }}
                    {...props}
                  &gt;
                    {children}
                  &lt;/div&gt;
                );
              }
           }
```

&gt;  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**
&gt;
&gt; **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**
&gt;
&gt; ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )



- `강조 표시` 과 `코드 인용`

강조 표시와 코드 인용은 모두 &lt;code&gt; 형태로 출력된다.

이 때 차이점은 **강조문**은 `inline 속성`을 가지고 있으며 (줄바꿈이 안 일어난다)

**코드 인용**은 `block 속성`을 가지고 있다는 것이다. (줄바꿈이 일어난다)



그리고 코드 인용에서 `match 속성`은 사용 언어를 뜻한다. (언어가 설정되지 않은 코드 인용 구문은 match 값이 false가 된다)



따라서 강조 표시와 코드 인용은 다음과 같이 적으면 된다.

```react
components={
            code({ node, inline, className, children, ...props }) {
                const match = /language-(\w+)/.exec(className || &quot;&quot;);
                return inline ? (
                  // 강조
                  &lt;code
                    style={{
                      background: &quot;var(--highlight-color)&quot;,
                      padding: &quot;2px&quot;,
                    }}
                    {...props}
                  &gt;
                    {children}
                  &lt;/code&gt;
                ) : match ? (
                  // 코드
                  // 언어가 선택됨
                  &lt;SyntaxHighlighter
                    children={String(children).replace(/\n$/, &quot;&quot;)}
                    style={nord}
                    language={match[1]}
                    PreTag=&quot;div&quot;
                    {...props}
                  /&gt;
                ) : (
                  // 언어가 선택되지 않음
                  &lt;SyntaxHighlighter
                    children={String(children).replace(/\n$/, &quot;&quot;)}
                    style={nord}
                    language=&quot;textile&quot;
                    PreTag=&quot;div&quot;
                    {...props}
                  /&gt;
                );
              }
           }
```

&gt;  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**
&gt;
&gt; **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**
&gt;
&gt; ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )



### react-markdown 사용 시 `공백 줄` 문제

- 현상 : react-markdown에서는 공백인 줄이 표현 X



- 해결

```javascript
markdown.replace(/\n\s\n\s/gi, &quot;\n\n&amp;nbsp;\n\n&quot;)
```

마크다운 파일의 텍스트를 위와 같이 바꿔 줌으로 써 해결

**이 때! 정확한 원인은 모르겠지만 Local에선 `\n\n &amp;nbsp;`로도 줄바꿈이 가능하지만 Github에 업로드 하면 줄바꿈이 되지 않는 문제 발생**

**인코딩 상의 문제인지 \n을 두 번 해줘야 줄바꿈이 됨 =&gt; `\n\n&amp;nbsp;\n\n`로 바꿔야 함**



마크다운 파일에서 `기본 줄바꿈`은 `엔터 두 번`

`공백이 있는 줄`은 `엔터 네 번`으로 변환



엔터 뒤에는 공백이 하나 있기 때문에 `\n\s\n\s`를 정규표현식으로 찾아서 변환해야 한다.



### react-markdown 사용 시 &lt;u&gt;`밑줄`&lt;/u&gt; 문제

- 현상 : react-markdown에서는 밑줄이 표현 X



- 해결

`먼저 em 태그의 css를 밑줄로 변경`

```javascript
markdown
    .replace(/\n\s\n\s/gi, &quot;\n\n&amp;nbsp;\n\n&quot;)
    .replace(/\*\*/gi, &quot;@$_%!\^&quot;)
    .replace(/\**\*/gi, &quot;/&quot;)
    .replace(/@\$_%!\^/gi, &quot;**&quot;)
    .replace(/&lt;\/?u&gt;/gi, &quot;*&quot;)
```

1. 우선 &lt;u&gt;강조 표시&lt;/u&gt;를 `사용하지 않는 특수문자 묶음`으로 변환 (위 세 번째 줄(@$_%!\^)에서 ^앞의 \는 자동 변환을 막기 위해 추가 ; 이게 없으면 파싱 중 자동으로 **로 변환됨)
2. &lt;u&gt;이탤릭체&lt;/u&gt;를 `슬래쉬`로 변환
3. `강조 표시를 다시 복구`
4. &lt;u&gt;언더 바 태그&lt;/u&gt;를 `이탤릭체`로 변환 =&gt; &lt;u&gt;**변환된 이탤릭체는 밑줄로 표시**&lt;/u&gt;



"/><meta property="og:type" content="website"/><meta property="og:title" content="[GitHub Blog 개발기] Markdown 적용 및 Require 함수"/><meta property="og:description" content="# [GitHub Blog 개발기] Markdown 적용 및 Require 함수

자주 업데이트 되는 Articles 항목은 Markdown으로 작성하기로 결정했다.



Local에 있는 Markdown 파일을 화면에 출력하는 방법은 다음과 같다.



## 1. Markdown 파일을 &lt;u&gt;가져오기&lt;/u&gt;

&gt; [요약]
&gt;
&gt; - JavaScript의 Require 함수를 이용해서 Local에 있는 Markdown 파일의 내용을 저장



**Local에 있는 Markdown 파일을 가져오기 위해서 JavaScript의 Require 함수를 사용했다.**



### JavaScript `Require`

**Require()** : &lt;u&gt;모듈을 가져오는 함수&lt;/u&gt; (정확히는 Modules의 exports를 가져오는 함수)

=&gt; 이 Require()를 이용해서 `Markdown 파일의 Text 정보`를 가져올 수 있다.



#### 순서 1

`require()`를 통해 content data에 담겨있는 path 정보를 이용해서 파일의 정보를 가져온다.

```javascript
const readmePath = require(`store/article_data/${path.split(&quot;/&quot;)[2]}/${
      path.split(&quot;/&quot;)[3]
    }`);
```



#### 순서 2

`fetch() - then() - text()` 과정을 통해 text 정보를 읽는다.

```javascript
fetch(readmePath.default)
    .then(r =&gt; r.text())
    .then(text =&gt; {
      setMarkdown(text);
    });
```



#### Require란?

만약 Javascript 파일을 읽는다면 exports 정보들을, **.default** 를 이용하면 default 값을, **.변수** 를 이용하면 해당 파일에서 exports 된 변수 값을 읽을 수 있다.



Import와 상당히 유사하다.

그렇다면 차이점은 무엇일까?

- require()
  - node.js문
  - 어디서나 호출 가능
  - 파일 전체를 사용



- import()
  - ES6문
  - 시작 부분에서만 호출 가능
  - 필요한 부분만 선택 가능 =&gt; &lt;u&gt;성능이 우수하고 메모리를 절약&lt;/u&gt;



=&gt; 그럼 import가 성능이 더 좋은데 왜 require를 썼는가?

**import는 최상단에서만 호출 가능하여 조건문에 따라 호출이 불가능 하기 때문**





## 2. Markdown 형식으로 &lt;u&gt;출력하기&lt;/u&gt;

&gt; [요약]
&gt;
&gt; - react-markdown 을 사용
&gt; - markdown -&gt; html 으로 변환된 코드에 대한 styling
&gt; - JavaScript를 변화시켜 줌으로써 추가 styling



### react-markdown

#### 설치

먼저 React에서Markdown 형식으로 출력을 시켜줄 `react-markdown`을 설치 (공식문서 : https://www.npmjs.com/package/react-markdown)

```bash
npm install react-markdown
```



#### 사용

(위에서 setMarkdown(text)으로 저장한 markdown 변수를 markdown으로 출력하는 방법)

**`&lt;ReactMarkdown&gt; 태그를 Return 함으로써 출력`**

```react
&lt;ReactMarkdown children={markdown} /&gt;
```



이렇게만 해도 어느정도 Markdown 형태가 잡힌다.



**하지만! &lt;u&gt;이렇게 두면 엉망진창의 예쁘지 않은 글이 된다&lt;/u&gt;**



그럼 입맛대로 꾸미는 법을 알아보자!



### remark-gfm

#### 설치

공식문서에 소개된 것처럼 `remark-gfm`을 설치하면 link, table, checklist 등의 형식을 표현할 수 있다.

```bash
npm install remark-gfm
```



#### 사용

ReactMarkdown 태그 안에 Plugin 형태로 추가하면 끝!

```react
&lt;ReactMarkdown remarkPlugins={[remarkGfm]} children={markdown} /&gt;



### 커스터마이즈 (react-syntax-highlighter)

강조 표시, 인용 표시, 코드 인용을 위해서는 추가적인 작업이 필요하다.

#### 설치

그 중 코드 인용은 `react-syntax-highlighter`를 통해 표시가 가능하다.

​```bash
npm install react-syntax-highlighter
```



#### 사용

1. 먼저 components 속성을 ReactMardown 태그 안에 추가한다.
2. 수정하고 싶은 태그를 적고 수정된 결과물을 return에 넣는다.

```react
&lt;ReactMarkdown remarkPlugins={[remarkGfm]} children={markdown}
    components={
        %%%수정할 태그%%%({ node, inline, className, children, ...props }) { return %%%수정된 태그%%% }
    }
    /&gt;
```

&gt;  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**
&gt;
&gt; **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**
&gt;
&gt; ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )



위 components 속성은 다음과 같이 작동한다.

1. ReactMarkdown이 html화 시킨 코드를 하나씩 읽는다.
2. components 안에 속하는 태그를 찾는다.
3. **조건문**을 통해 커스텀을 하는 조건을 선택한다.
4. 조건을 만족했을 때 **수정된 태그** 를 반환한다.



#### 예시

- `인용 표시`

인용문은 &lt;blockquote&gt; 형태로 출력되기 때문에 인용문을 바꾸고 싶다면 다음과 같이 적으면 된다.

```react
components={
            // 인용문
            blockquote({ node, children, ...props }) {
                return (
                  &lt;div
                    style={{
                      background: &quot;#f0f0f0&quot;,
                      padding: &quot;1px 15px&quot;,
                      borderRadius: &quot;10px&quot;,
                    }}
                    {...props}
                  &gt;
                    {children}
                  &lt;/div&gt;
                );
              }
           }
```

&gt;  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**
&gt;
&gt; **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**
&gt;
&gt; ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )



- `강조 표시` 과 `코드 인용`

강조 표시와 코드 인용은 모두 &lt;code&gt; 형태로 출력된다.

이 때 차이점은 **강조문**은 `inline 속성`을 가지고 있으며 (줄바꿈이 안 일어난다)

**코드 인용**은 `block 속성`을 가지고 있다는 것이다. (줄바꿈이 일어난다)



그리고 코드 인용에서 `match 속성`은 사용 언어를 뜻한다. (언어가 설정되지 않은 코드 인용 구문은 match 값이 false가 된다)



따라서 강조 표시와 코드 인용은 다음과 같이 적으면 된다.

```react
components={
            code({ node, inline, className, children, ...props }) {
                const match = /language-(\w+)/.exec(className || &quot;&quot;);
                return inline ? (
                  // 강조
                  &lt;code
                    style={{
                      background: &quot;var(--highlight-color)&quot;,
                      padding: &quot;2px&quot;,
                    }}
                    {...props}
                  &gt;
                    {children}
                  &lt;/code&gt;
                ) : match ? (
                  // 코드
                  // 언어가 선택됨
                  &lt;SyntaxHighlighter
                    children={String(children).replace(/\n$/, &quot;&quot;)}
                    style={nord}
                    language={match[1]}
                    PreTag=&quot;div&quot;
                    {...props}
                  /&gt;
                ) : (
                  // 언어가 선택되지 않음
                  &lt;SyntaxHighlighter
                    children={String(children).replace(/\n$/, &quot;&quot;)}
                    style={nord}
                    language=&quot;textile&quot;
                    PreTag=&quot;div&quot;
                    {...props}
                  /&gt;
                );
              }
           }
```

&gt;  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**
&gt;
&gt; **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**
&gt;
&gt; ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )



### react-markdown 사용 시 `공백 줄` 문제

- 현상 : react-markdown에서는 공백인 줄이 표현 X



- 해결

```javascript
markdown.replace(/\n\s\n\s/gi, &quot;\n\n&amp;nbsp;\n\n&quot;)
```

마크다운 파일의 텍스트를 위와 같이 바꿔 줌으로 써 해결

**이 때! 정확한 원인은 모르겠지만 Local에선 `\n\n &amp;nbsp;`로도 줄바꿈이 가능하지만 Github에 업로드 하면 줄바꿈이 되지 않는 문제 발생**

**인코딩 상의 문제인지 \n을 두 번 해줘야 줄바꿈이 됨 =&gt; `\n\n&amp;nbsp;\n\n`로 바꿔야 함**



마크다운 파일에서 `기본 줄바꿈`은 `엔터 두 번`

`공백이 있는 줄`은 `엔터 네 번`으로 변환



엔터 뒤에는 공백이 하나 있기 때문에 `\n\s\n\s`를 정규표현식으로 찾아서 변환해야 한다.



### react-markdown 사용 시 &lt;u&gt;`밑줄`&lt;/u&gt; 문제

- 현상 : react-markdown에서는 밑줄이 표현 X



- 해결

`먼저 em 태그의 css를 밑줄로 변경`

```javascript
markdown
    .replace(/\n\s\n\s/gi, &quot;\n\n&amp;nbsp;\n\n&quot;)
    .replace(/\*\*/gi, &quot;@$_%!\^&quot;)
    .replace(/\**\*/gi, &quot;/&quot;)
    .replace(/@\$_%!\^/gi, &quot;**&quot;)
    .replace(/&lt;\/?u&gt;/gi, &quot;*&quot;)
```

1. 우선 &lt;u&gt;강조 표시&lt;/u&gt;를 `사용하지 않는 특수문자 묶음`으로 변환 (위 세 번째 줄(@$_%!\^)에서 ^앞의 \는 자동 변환을 막기 위해 추가 ; 이게 없으면 파싱 중 자동으로 **로 변환됨)
2. &lt;u&gt;이탤릭체&lt;/u&gt;를 `슬래쉬`로 변환
3. `강조 표시를 다시 복구`
4. &lt;u&gt;언더 바 태그&lt;/u&gt;를 `이탤릭체`로 변환 =&gt; &lt;u&gt;**변환된 이탤릭체는 밑줄로 표시**&lt;/u&gt;



"/><meta property="og:site_name" content="웅&#x27;s 블로그"/><link rel="icon" href="/myLogo_transp.png"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-90a60b87fd0d5fc150f2.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-65394d1789547644d68b.js" defer=""></script><script src="/_next/static/chunks/485-1121db7a55400d486874.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5BarticleCategory%5D/%5BarticleId%5D-9ceb51083ce229176f1f.js" defer=""></script><script src="/_next/static/ZLPtRBag0J7rFKOAVP_J6/_buildManifest.js" defer=""></script><script src="/_next/static/ZLPtRBag0J7rFKOAVP_J6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App"><div class="App__Content"><div class="Header_Header__1J9sN"><div class="Header_Header__styling__U361E"><img src="/myLogo_transp.png" alt="logo"/></div><a class="Header_Header__word__hqgKV" href="/">Home</a><a class="Header_Header__word__hqgKV" href="/profile">Profile</a><a class="Header_Header__word__hqgKV" href="/articles">Articles</a><a class="Header_Header__word__hqgKV" href="/archives">Archives</a><div class="Header_Header__styling_Reverse__2G1sc"></div></div><div><main><div class="globalStyles_loader__29zgS"><span>Loading...</span></div></main></div></div><div class="Footer_Footer__16BK3"><div class="Footer_Footer__github__3FRw-">Github : <a href="https://github.com/ParkJeongwoong">ParkJeongwoong</a></div><div class="Footer_Footer__email__gbWyz">Contact : <span>dvlprjw@gmail.com</span></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdown":"# [GitHub Blog 개발기] Markdown 적용 및 Require 함수\r\n\r\n자주 업데이트 되는 Articles 항목은 Markdown으로 작성하기로 결정했다.\r\n\r\n\r\n\r\nLocal에 있는 Markdown 파일을 화면에 출력하는 방법은 다음과 같다.\r\n\r\n\r\n\r\n## 1. Markdown 파일을 \u003cu\u003e가져오기\u003c/u\u003e\r\n\r\n\u003e [요약]\r\n\u003e\r\n\u003e - JavaScript의 Require 함수를 이용해서 Local에 있는 Markdown 파일의 내용을 저장\r\n\r\n\r\n\r\n**Local에 있는 Markdown 파일을 가져오기 위해서 JavaScript의 Require 함수를 사용했다.**\r\n\r\n\r\n\r\n### JavaScript `Require`\r\n\r\n**Require()** : \u003cu\u003e모듈을 가져오는 함수\u003c/u\u003e (정확히는 Modules의 exports를 가져오는 함수)\r\n\r\n=\u003e 이 Require()를 이용해서 `Markdown 파일의 Text 정보`를 가져올 수 있다.\r\n\r\n\r\n\r\n#### 순서 1\r\n\r\n`require()`를 통해 content data에 담겨있는 path 정보를 이용해서 파일의 정보를 가져온다.\r\n\r\n```javascript\r\nconst readmePath = require(`store/article_data/${path.split(\"/\")[2]}/${\r\n      path.split(\"/\")[3]\r\n    }`);\r\n```\r\n\r\n\r\n\r\n#### 순서 2\r\n\r\n`fetch() - then() - text()` 과정을 통해 text 정보를 읽는다.\r\n\r\n```javascript\r\nfetch(readmePath.default)\r\n    .then(r =\u003e r.text())\r\n    .then(text =\u003e {\r\n      setMarkdown(text);\r\n    });\r\n```\r\n\r\n\r\n\r\n#### Require란?\r\n\r\n만약 Javascript 파일을 읽는다면 exports 정보들을, **.default** 를 이용하면 default 값을, **.변수** 를 이용하면 해당 파일에서 exports 된 변수 값을 읽을 수 있다.\r\n\r\n\r\n\r\nImport와 상당히 유사하다.\r\n\r\n그렇다면 차이점은 무엇일까?\r\n\r\n- require()\r\n  - node.js문\r\n  - 어디서나 호출 가능\r\n  - 파일 전체를 사용\r\n\r\n\r\n\r\n- import()\r\n  - ES6문\r\n  - 시작 부분에서만 호출 가능\r\n  - 필요한 부분만 선택 가능 =\u003e \u003cu\u003e성능이 우수하고 메모리를 절약\u003c/u\u003e\r\n\r\n\r\n\r\n=\u003e 그럼 import가 성능이 더 좋은데 왜 require를 썼는가?\r\n\r\n**import는 최상단에서만 호출 가능하여 조건문에 따라 호출이 불가능 하기 때문**\r\n\r\n\r\n\r\n\r\n\r\n## 2. Markdown 형식으로 \u003cu\u003e출력하기\u003c/u\u003e\r\n\r\n\u003e [요약]\r\n\u003e\r\n\u003e - react-markdown 을 사용\r\n\u003e - markdown -\u003e html 으로 변환된 코드에 대한 styling\r\n\u003e - JavaScript를 변화시켜 줌으로써 추가 styling\r\n\r\n\r\n\r\n### react-markdown\r\n\r\n#### 설치\r\n\r\n먼저 React에서Markdown 형식으로 출력을 시켜줄 `react-markdown`을 설치 (공식문서 : https://www.npmjs.com/package/react-markdown)\r\n\r\n```bash\r\nnpm install react-markdown\r\n```\r\n\r\n\r\n\r\n#### 사용\r\n\r\n(위에서 setMarkdown(text)으로 저장한 markdown 변수를 markdown으로 출력하는 방법)\r\n\r\n**`\u003cReactMarkdown\u003e 태그를 Return 함으로써 출력`**\r\n\r\n```react\r\n\u003cReactMarkdown children={markdown} /\u003e\r\n```\r\n\r\n\r\n\r\n이렇게만 해도 어느정도 Markdown 형태가 잡힌다.\r\n\r\n\r\n\r\n**하지만! \u003cu\u003e이렇게 두면 엉망진창의 예쁘지 않은 글이 된다\u003c/u\u003e**\r\n\r\n\r\n\r\n그럼 입맛대로 꾸미는 법을 알아보자!\r\n\r\n\r\n\r\n### remark-gfm\r\n\r\n#### 설치\r\n\r\n공식문서에 소개된 것처럼 `remark-gfm`을 설치하면 link, table, checklist 등의 형식을 표현할 수 있다.\r\n\r\n```bash\r\nnpm install remark-gfm\r\n```\r\n\r\n\r\n\r\n#### 사용\r\n\r\nReactMarkdown 태그 안에 Plugin 형태로 추가하면 끝!\r\n\r\n```react\r\n\u003cReactMarkdown remarkPlugins={[remarkGfm]} children={markdown} /\u003e\r\n\r\n\r\n\r\n### 커스터마이즈 (react-syntax-highlighter)\r\n\r\n강조 표시, 인용 표시, 코드 인용을 위해서는 추가적인 작업이 필요하다.\r\n\r\n#### 설치\r\n\r\n그 중 코드 인용은 `react-syntax-highlighter`를 통해 표시가 가능하다.\r\n\r\n​```bash\r\nnpm install react-syntax-highlighter\r\n```\r\n\r\n\r\n\r\n#### 사용\r\n\r\n1. 먼저 components 속성을 ReactMardown 태그 안에 추가한다.\r\n2. 수정하고 싶은 태그를 적고 수정된 결과물을 return에 넣는다.\r\n\r\n```react\r\n\u003cReactMarkdown remarkPlugins={[remarkGfm]} children={markdown}\r\n    components={\r\n        %%%수정할 태그%%%({ node, inline, className, children, ...props }) { return %%%수정된 태그%%% }\r\n    }\r\n    /\u003e\r\n```\r\n\r\n\u003e  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**\r\n\u003e\r\n\u003e **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**\r\n\u003e\r\n\u003e ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )\r\n\r\n\r\n\r\n위 components 속성은 다음과 같이 작동한다.\r\n\r\n1. ReactMarkdown이 html화 시킨 코드를 하나씩 읽는다.\r\n2. components 안에 속하는 태그를 찾는다.\r\n3. **조건문**을 통해 커스텀을 하는 조건을 선택한다.\r\n4. 조건을 만족했을 때 **수정된 태그** 를 반환한다.\r\n\r\n\r\n\r\n#### 예시\r\n\r\n- `인용 표시`\r\n\r\n인용문은 \u003cblockquote\u003e 형태로 출력되기 때문에 인용문을 바꾸고 싶다면 다음과 같이 적으면 된다.\r\n\r\n```react\r\ncomponents={\r\n            // 인용문\r\n            blockquote({ node, children, ...props }) {\r\n                return (\r\n                  \u003cdiv\r\n                    style={{\r\n                      background: \"#f0f0f0\",\r\n                      padding: \"1px 15px\",\r\n                      borderRadius: \"10px\",\r\n                    }}\r\n                    {...props}\r\n                  \u003e\r\n                    {children}\r\n                  \u003c/div\u003e\r\n                );\r\n              }\r\n           }\r\n```\r\n\r\n\u003e  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**\r\n\u003e\r\n\u003e **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**\r\n\u003e\r\n\u003e ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )\r\n\r\n\r\n\r\n- `강조 표시` 과 `코드 인용`\r\n\r\n강조 표시와 코드 인용은 모두 \u003ccode\u003e 형태로 출력된다.\r\n\r\n이 때 차이점은 **강조문**은 `inline 속성`을 가지고 있으며 (줄바꿈이 안 일어난다)\r\n\r\n**코드 인용**은 `block 속성`을 가지고 있다는 것이다. (줄바꿈이 일어난다)\r\n\r\n\r\n\r\n그리고 코드 인용에서 `match 속성`은 사용 언어를 뜻한다. (언어가 설정되지 않은 코드 인용 구문은 match 값이 false가 된다)\r\n\r\n\r\n\r\n따라서 강조 표시와 코드 인용은 다음과 같이 적으면 된다.\r\n\r\n```react\r\ncomponents={\r\n            code({ node, inline, className, children, ...props }) {\r\n                const match = /language-(\\w+)/.exec(className || \"\");\r\n                return inline ? (\r\n                  // 강조\r\n                  \u003ccode\r\n                    style={{\r\n                      background: \"var(--highlight-color)\",\r\n                      padding: \"2px\",\r\n                    }}\r\n                    {...props}\r\n                  \u003e\r\n                    {children}\r\n                  \u003c/code\u003e\r\n                ) : match ? (\r\n                  // 코드\r\n                  // 언어가 선택됨\r\n                  \u003cSyntaxHighlighter\r\n                    children={String(children).replace(/\\n$/, \"\")}\r\n                    style={nord}\r\n                    language={match[1]}\r\n                    PreTag=\"div\"\r\n                    {...props}\r\n                  /\u003e\r\n                ) : (\r\n                  // 언어가 선택되지 않음\r\n                  \u003cSyntaxHighlighter\r\n                    children={String(children).replace(/\\n$/, \"\")}\r\n                    style={nord}\r\n                    language=\"textile\"\r\n                    PreTag=\"div\"\r\n                    {...props}\r\n                  /\u003e\r\n                );\r\n              }\r\n           }\r\n```\r\n\r\n\u003e  **! github 페이지에선 중괄호( `{}` )를 중첩해서 사용하면 에러가 나기 때문에 중괄호를 하나만 사용했다.**\r\n\u003e\r\n\u003e **실제로는 component={ } 에서 중괄호를 두 번 작성해야 한다.**\r\n\u003e\r\n\u003e ( 소스코드 참고 : https://github.com/ParkJeongwoong/ParkJeongwoong.github.io/blob/master/src/components/Markdown/MarkdownRenderer.js )\r\n\r\n\r\n\r\n### react-markdown 사용 시 `공백 줄` 문제\r\n\r\n- 현상 : react-markdown에서는 공백인 줄이 표현 X\r\n\r\n\r\n\r\n- 해결\r\n\r\n```javascript\r\nmarkdown.replace(/\\n\\s\\n\\s/gi, \"\\n\\n\u0026nbsp;\\n\\n\")\r\n```\r\n\r\n마크다운 파일의 텍스트를 위와 같이 바꿔 줌으로 써 해결\r\n\r\n**이 때! 정확한 원인은 모르겠지만 Local에선 `\\n\\n \u0026nbsp;`로도 줄바꿈이 가능하지만 Github에 업로드 하면 줄바꿈이 되지 않는 문제 발생**\r\n\r\n**인코딩 상의 문제인지 \\n을 두 번 해줘야 줄바꿈이 됨 =\u003e `\\n\\n\u0026nbsp;\\n\\n`로 바꿔야 함**\r\n\r\n\r\n\r\n마크다운 파일에서 `기본 줄바꿈`은 `엔터 두 번`\r\n\r\n`공백이 있는 줄`은 `엔터 네 번`으로 변환\r\n\r\n\r\n\r\n엔터 뒤에는 공백이 하나 있기 때문에 `\\n\\s\\n\\s`를 정규표현식으로 찾아서 변환해야 한다.\r\n\r\n\r\n\r\n### react-markdown 사용 시 \u003cu\u003e`밑줄`\u003c/u\u003e 문제\r\n\r\n- 현상 : react-markdown에서는 밑줄이 표현 X\r\n\r\n\r\n\r\n- 해결\r\n\r\n`먼저 em 태그의 css를 밑줄로 변경`\r\n\r\n```javascript\r\nmarkdown\r\n    .replace(/\\n\\s\\n\\s/gi, \"\\n\\n\u0026nbsp;\\n\\n\")\r\n    .replace(/\\*\\*/gi, \"@$_%!\\^\")\r\n    .replace(/\\**\\*/gi, \"/\")\r\n    .replace(/@\\$_%!\\^/gi, \"**\")\r\n    .replace(/\u003c\\/?u\u003e/gi, \"*\")\r\n```\r\n\r\n1. 우선 \u003cu\u003e강조 표시\u003c/u\u003e를 `사용하지 않는 특수문자 묶음`으로 변환 (위 세 번째 줄(@$_%!\\^)에서 ^앞의 \\는 자동 변환을 막기 위해 추가 ; 이게 없으면 파싱 중 자동으로 **로 변환됨)\r\n2. \u003cu\u003e이탤릭체\u003c/u\u003e를 `슬래쉬`로 변환\r\n3. `강조 표시를 다시 복구`\r\n4. \u003cu\u003e언더 바 태그\u003c/u\u003e를 `이탤릭체`로 변환 =\u003e \u003cu\u003e**변환된 이탤릭체는 밑줄로 표시**\u003c/u\u003e\r\n\r\n\r\n\r\n","documentTitle":"[GitHub Blog 개발기] Markdown 적용 및 Require 함수"},"__N_SSG":true},"page":"/articles/[articleCategory]/[articleId]","query":{"articleCategory":"Develop","articleId":"3"},"buildId":"ZLPtRBag0J7rFKOAVP_J6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>