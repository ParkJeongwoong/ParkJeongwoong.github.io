<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>[Spring] 생명주기 (Life Cycle) | 웅&#x27;s 블로그</title><meta name="description" content="# [Spring] 생명주기 (Life Cycle)

스프링에서 다룰 생성주기는 크게 [컨테이너]의 생명주기와 [빈 객체]의 생성주기로 나뉜다.



## 스프링 컨테이너 생명주기

**생성** - **설정** - **사용** - **소멸**



- 생성
  - GenericXmlApplicationContext 를 이용한 스프링 컨테이너 초기화(생성)

```java
GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
```



- 설정
  - load() 를 이용한 컨테이너 설정 (&lt;u&gt;refresh() 를 해야 반영&lt;/u&gt;)

```java
ctx.load(&quot;classpath:applicationCTX.xml&quot;);
ctx.refresh();
```



- 사용
  - getBean() 을 이용한 Bean 객체 사용

```java
BookRegisterService bookRegisterService = ctx.getBean(&quot;bookRegisterService&quot;, BookRegisterService.class);

BookSearchService bookSearchService = ctx.getBean(&quot;bookSearchService&quot;, BookSearchService.class);
```



- 종료
  - close() 를 이용한 스프링 컨테이너 종료

```java
ctx.close();
```



### 컨테이너와 빈 객체를 동시에 생성하는 방법 (컨테이너, 빈 객체 동시 생성)

```java
GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(&quot;classpath:appCtx.xml&quot;);
```

이 방법을 사용하면 스프링 컨테이너를 생성하면서 빈 객체도 동시에 생성된다.





## Bean 객체 생명주기

**Bean 객체의 생명주기는 스프링 컨테이너의 생명주기와 동일**

컨테이너를 생성할 때 Bean이 생성되고, getBean()은 생성된 Bean 객체를 불러오는 것



### Bean 객체 생명주기 활용법

#### 1) `interface` 활용

- &lt;interface&gt; InitializingBean 에서 `afterPropertiesSet` 을 제공 (**bean 객체 생성 시 호출**)
- &lt;interface&gt; DisposableBean 에서 `destroy` 를 제공 (**bean 객체 소멸 시 호출**)

```java
public class BookRegisterService implements InitializingBean, DisposableBean {
    @Autowired
    private	BookDao bookDao;
    
    public BookRegisterService() {}
    
    public void register(Book book) {
        bookDao.insert(book);
    }    
    
    // 빈 객체 생성 시 호출
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;BookRegisterService 빈 객체 생성 단계&quot;)
    }
    
    // 빈 객체 소멸 시 호출
    public void destroy() throws Exception {
        System.out.println(&quot;BookRegisterService 빈 객체 소멸 단계&quot;)
    }
    
}
```

```java
public static void main(String[] args) {
    GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(); // (1) 컨테이너생성
    ctx.load(&quot;classpath:applicationCTX.xml&quot;); // (2) 로드
    ctx.refresh(); // (3) 빈 생성(즉, 빈이 초기화 과정에서 호출된다. interface:InitializingBean, method:afterPropertiesSet() )
    ctx.close(); // (4) 빈 소멸(빈 소멸 과정에서 생성 된다. interface:DisposableBean , method:destroy() )
}
```



#### 2) `init-method`, `destroy-method` 속성 활용

```xml
&lt;bean id=&quot;bookRegisterService&quot; class=&quot;com.brms.book.service.BookRegisterService&quot;
      	init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot; /&gt;
```

```java
public class BookRegisterService {
    @Autowired
    private	BookDao bookDao;
    
    public BookRegisterService() {}
    
    public void register(Book book) {
        bookDao.insert(book);
    }
    
    // 빈 객체 생성 시 호출
    public void initMethod() {
        System.out.println(&quot;BookRegisterService 빈 객체 생성 단계&quot;)
    }
    
    // 빈 객체 소멸 시 호출
    public void destroyMethod() {
        System.out.println(&quot;BookRegisterService 빈 객체 소멸 단계&quot;)
    }
}
```



#### 3) `@PostConstruct`, `@PreDestroy` 어노테이션 사용

스프링 2.5이 후부터 사용 가능

```java
public class BookRegisterService {
    @Autowired
    private	BookDao bookDao;
    
    public BookRegisterService() {}
    
    public void register(Book book) {
        bookDao.insert(book);
    }
    
    // 빈 객체 생성 시 호출
    @PostConstruct
    public void initMethod() {
        System.out.println(&quot;BookRegisterService 빈 객체 생성 단계&quot;)
    }
    
    // 빈 객체 소멸 시 호출
    @PreDestroy
    public void destroyMethod() {
        System.out.println(&quot;BookRegisterService 빈 객체 소멸 단계&quot;)
    }
}
```





## 출처

인프런 - 자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌

https://bkjeon1614.tistory.com/482

https://request-response.tistory.com/11

https://haruhiism.tistory.com/186"/><meta property="og:type" content="website"/><meta property="og:title" content="[Spring] 생명주기 (Life Cycle)"/><meta property="og:description" content="# [Spring] 생명주기 (Life Cycle)

스프링에서 다룰 생성주기는 크게 [컨테이너]의 생명주기와 [빈 객체]의 생성주기로 나뉜다.



## 스프링 컨테이너 생명주기

**생성** - **설정** - **사용** - **소멸**



- 생성
  - GenericXmlApplicationContext 를 이용한 스프링 컨테이너 초기화(생성)

```java
GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
```



- 설정
  - load() 를 이용한 컨테이너 설정 (&lt;u&gt;refresh() 를 해야 반영&lt;/u&gt;)

```java
ctx.load(&quot;classpath:applicationCTX.xml&quot;);
ctx.refresh();
```



- 사용
  - getBean() 을 이용한 Bean 객체 사용

```java
BookRegisterService bookRegisterService = ctx.getBean(&quot;bookRegisterService&quot;, BookRegisterService.class);

BookSearchService bookSearchService = ctx.getBean(&quot;bookSearchService&quot;, BookSearchService.class);
```



- 종료
  - close() 를 이용한 스프링 컨테이너 종료

```java
ctx.close();
```



### 컨테이너와 빈 객체를 동시에 생성하는 방법 (컨테이너, 빈 객체 동시 생성)

```java
GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(&quot;classpath:appCtx.xml&quot;);
```

이 방법을 사용하면 스프링 컨테이너를 생성하면서 빈 객체도 동시에 생성된다.





## Bean 객체 생명주기

**Bean 객체의 생명주기는 스프링 컨테이너의 생명주기와 동일**

컨테이너를 생성할 때 Bean이 생성되고, getBean()은 생성된 Bean 객체를 불러오는 것



### Bean 객체 생명주기 활용법

#### 1) `interface` 활용

- &lt;interface&gt; InitializingBean 에서 `afterPropertiesSet` 을 제공 (**bean 객체 생성 시 호출**)
- &lt;interface&gt; DisposableBean 에서 `destroy` 를 제공 (**bean 객체 소멸 시 호출**)

```java
public class BookRegisterService implements InitializingBean, DisposableBean {
    @Autowired
    private	BookDao bookDao;
    
    public BookRegisterService() {}
    
    public void register(Book book) {
        bookDao.insert(book);
    }    
    
    // 빈 객체 생성 시 호출
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;BookRegisterService 빈 객체 생성 단계&quot;)
    }
    
    // 빈 객체 소멸 시 호출
    public void destroy() throws Exception {
        System.out.println(&quot;BookRegisterService 빈 객체 소멸 단계&quot;)
    }
    
}
```

```java
public static void main(String[] args) {
    GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(); // (1) 컨테이너생성
    ctx.load(&quot;classpath:applicationCTX.xml&quot;); // (2) 로드
    ctx.refresh(); // (3) 빈 생성(즉, 빈이 초기화 과정에서 호출된다. interface:InitializingBean, method:afterPropertiesSet() )
    ctx.close(); // (4) 빈 소멸(빈 소멸 과정에서 생성 된다. interface:DisposableBean , method:destroy() )
}
```



#### 2) `init-method`, `destroy-method` 속성 활용

```xml
&lt;bean id=&quot;bookRegisterService&quot; class=&quot;com.brms.book.service.BookRegisterService&quot;
      	init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot; /&gt;
```

```java
public class BookRegisterService {
    @Autowired
    private	BookDao bookDao;
    
    public BookRegisterService() {}
    
    public void register(Book book) {
        bookDao.insert(book);
    }
    
    // 빈 객체 생성 시 호출
    public void initMethod() {
        System.out.println(&quot;BookRegisterService 빈 객체 생성 단계&quot;)
    }
    
    // 빈 객체 소멸 시 호출
    public void destroyMethod() {
        System.out.println(&quot;BookRegisterService 빈 객체 소멸 단계&quot;)
    }
}
```



#### 3) `@PostConstruct`, `@PreDestroy` 어노테이션 사용

스프링 2.5이 후부터 사용 가능

```java
public class BookRegisterService {
    @Autowired
    private	BookDao bookDao;
    
    public BookRegisterService() {}
    
    public void register(Book book) {
        bookDao.insert(book);
    }
    
    // 빈 객체 생성 시 호출
    @PostConstruct
    public void initMethod() {
        System.out.println(&quot;BookRegisterService 빈 객체 생성 단계&quot;)
    }
    
    // 빈 객체 소멸 시 호출
    @PreDestroy
    public void destroyMethod() {
        System.out.println(&quot;BookRegisterService 빈 객체 소멸 단계&quot;)
    }
}
```





## 출처

인프런 - 자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌

https://bkjeon1614.tistory.com/482

https://request-response.tistory.com/11

https://haruhiism.tistory.com/186"/><meta property="og:site_name" content="웅&#x27;s 블로그"/><link rel="icon" href="/myLogo_transp.png"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-90a60b87fd0d5fc150f2.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e58dc7723e56dbc99de5.js" defer=""></script><script src="/_next/static/chunks/485-1121db7a55400d486874.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5BarticleCategory%5D/%5BarticleId%5D-9ceb51083ce229176f1f.js" defer=""></script><script src="/_next/static/-7YfoXERBXO0va1TK21ln/_buildManifest.js" defer=""></script><script src="/_next/static/-7YfoXERBXO0va1TK21ln/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App"><div class="App__Content"><div class="Header_Header__1J9sN"><div class="Header_Header__styling__U361E"><img src="/myLogo_transp.png" alt="logo"/></div><a class="Header_Header__word__hqgKV" href="/">Home</a><a class="Header_Header__word__hqgKV" href="/profile">Profile</a><a class="Header_Header__word__hqgKV" href="/articles">Articles</a><a class="Header_Header__word__hqgKV" href="/archives">Archives</a><div class="Header_Header__styling_Reverse__2G1sc"></div></div><div><main><div class="globalStyles_loader__29zgS"><span>Loading...</span></div></main></div></div><div class="Footer_Footer__16BK3"><div class="Footer_Footer__github__3FRw-">Github : <a href="https://github.com/ParkJeongwoong">ParkJeongwoong</a></div><div class="Footer_Footer__email__gbWyz">Contact : <span>dvlprjw@gmail.com</span></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdown":"# [Spring] 생명주기 (Life Cycle)\r\n\r\n스프링에서 다룰 생성주기는 크게 [컨테이너]의 생명주기와 [빈 객체]의 생성주기로 나뉜다.\r\n\r\n\r\n\r\n## 스프링 컨테이너 생명주기\r\n\r\n**생성** - **설정** - **사용** - **소멸**\r\n\r\n\r\n\r\n- 생성\r\n  - GenericXmlApplicationContext 를 이용한 스프링 컨테이너 초기화(생성)\r\n\r\n```java\r\nGenericXmlApplicationContext ctx = new GenericXmlApplicationContext();\r\n```\r\n\r\n\r\n\r\n- 설정\r\n  - load() 를 이용한 컨테이너 설정 (\u003cu\u003erefresh() 를 해야 반영\u003c/u\u003e)\r\n\r\n```java\r\nctx.load(\"classpath:applicationCTX.xml\");\r\nctx.refresh();\r\n```\r\n\r\n\r\n\r\n- 사용\r\n  - getBean() 을 이용한 Bean 객체 사용\r\n\r\n```java\r\nBookRegisterService bookRegisterService = ctx.getBean(\"bookRegisterService\", BookRegisterService.class);\r\n\r\nBookSearchService bookSearchService = ctx.getBean(\"bookSearchService\", BookSearchService.class);\r\n```\r\n\r\n\r\n\r\n- 종료\r\n  - close() 를 이용한 스프링 컨테이너 종료\r\n\r\n```java\r\nctx.close();\r\n```\r\n\r\n\r\n\r\n### 컨테이너와 빈 객체를 동시에 생성하는 방법 (컨테이너, 빈 객체 동시 생성)\r\n\r\n```java\r\nGenericXmlApplicationContext ctx = new GenericXmlApplicationContext(\"classpath:appCtx.xml\");\r\n```\r\n\r\n이 방법을 사용하면 스프링 컨테이너를 생성하면서 빈 객체도 동시에 생성된다.\r\n\r\n\r\n\r\n\r\n\r\n## Bean 객체 생명주기\r\n\r\n**Bean 객체의 생명주기는 스프링 컨테이너의 생명주기와 동일**\r\n\r\n컨테이너를 생성할 때 Bean이 생성되고, getBean()은 생성된 Bean 객체를 불러오는 것\r\n\r\n\r\n\r\n### Bean 객체 생명주기 활용법\r\n\r\n#### 1) `interface` 활용\r\n\r\n- \u003cinterface\u003e InitializingBean 에서 `afterPropertiesSet` 을 제공 (**bean 객체 생성 시 호출**)\r\n- \u003cinterface\u003e DisposableBean 에서 `destroy` 를 제공 (**bean 객체 소멸 시 호출**)\r\n\r\n```java\r\npublic class BookRegisterService implements InitializingBean, DisposableBean {\r\n    @Autowired\r\n    private\tBookDao bookDao;\r\n    \r\n    public BookRegisterService() {}\r\n    \r\n    public void register(Book book) {\r\n        bookDao.insert(book);\r\n    }    \r\n    \r\n    // 빈 객체 생성 시 호출\r\n    @Override\r\n    public void afterPropertiesSet() throws Exception {\r\n        System.out.println(\"BookRegisterService 빈 객체 생성 단계\")\r\n    }\r\n    \r\n    // 빈 객체 소멸 시 호출\r\n    public void destroy() throws Exception {\r\n        System.out.println(\"BookRegisterService 빈 객체 소멸 단계\")\r\n    }\r\n    \r\n}\r\n```\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(); // (1) 컨테이너생성\r\n    ctx.load(\"classpath:applicationCTX.xml\"); // (2) 로드\r\n    ctx.refresh(); // (3) 빈 생성(즉, 빈이 초기화 과정에서 호출된다. interface:InitializingBean, method:afterPropertiesSet() )\r\n    ctx.close(); // (4) 빈 소멸(빈 소멸 과정에서 생성 된다. interface:DisposableBean , method:destroy() )\r\n}\r\n```\r\n\r\n\r\n\r\n#### 2) `init-method`, `destroy-method` 속성 활용\r\n\r\n```xml\r\n\u003cbean id=\"bookRegisterService\" class=\"com.brms.book.service.BookRegisterService\"\r\n      \tinit-method=\"initMethod\" destroy-method=\"destroyMethod\" /\u003e\r\n```\r\n\r\n```java\r\npublic class BookRegisterService {\r\n    @Autowired\r\n    private\tBookDao bookDao;\r\n    \r\n    public BookRegisterService() {}\r\n    \r\n    public void register(Book book) {\r\n        bookDao.insert(book);\r\n    }\r\n    \r\n    // 빈 객체 생성 시 호출\r\n    public void initMethod() {\r\n        System.out.println(\"BookRegisterService 빈 객체 생성 단계\")\r\n    }\r\n    \r\n    // 빈 객체 소멸 시 호출\r\n    public void destroyMethod() {\r\n        System.out.println(\"BookRegisterService 빈 객체 소멸 단계\")\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 3) `@PostConstruct`, `@PreDestroy` 어노테이션 사용\r\n\r\n스프링 2.5이 후부터 사용 가능\r\n\r\n```java\r\npublic class BookRegisterService {\r\n    @Autowired\r\n    private\tBookDao bookDao;\r\n    \r\n    public BookRegisterService() {}\r\n    \r\n    public void register(Book book) {\r\n        bookDao.insert(book);\r\n    }\r\n    \r\n    // 빈 객체 생성 시 호출\r\n    @PostConstruct\r\n    public void initMethod() {\r\n        System.out.println(\"BookRegisterService 빈 객체 생성 단계\")\r\n    }\r\n    \r\n    // 빈 객체 소멸 시 호출\r\n    @PreDestroy\r\n    public void destroyMethod() {\r\n        System.out.println(\"BookRegisterService 빈 객체 소멸 단계\")\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 출처\r\n\r\n인프런 - 자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌\r\n\r\nhttps://bkjeon1614.tistory.com/482\r\n\r\nhttps://request-response.tistory.com/11\r\n\r\nhttps://haruhiism.tistory.com/186","documentTitle":"[Spring] 생명주기 (Life Cycle)"},"__N_SSG":true},"page":"/articles/[articleCategory]/[articleId]","query":{"articleCategory":"Web","articleId":"4"},"buildId":"-7YfoXERBXO0va1TK21ln","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>