<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>[Spring] Controller 객체 | 웅&#x27;s 블로그</title><meta name="description" content="# [Spring] Controller 객체

오늘은 비즈니스 로직이 들어가 있는 Controller 객체에 대해 알아보겠습니다.



## URL 매핑 - `@RequestMapping`

사용자가 요청을 보내면 &lt;u&gt;(1) Dispatcher Servlet&lt;/u&gt;이 &lt;u&gt;(2) HandlerMapping&lt;/u&gt; 을 통해 적합한 Controller를 찾습니다. 

HandlerMapping의 방법엔 여러가지가 있는데 `@RequestMapping`은 그 중 하나인 **RequestMappingHandlerMapping** 방법에서 적합한 Controller 객체를 찾는 어노테이션입니다.

```java
@Controller
@RequestMapping(&quot;/member&quot;)
public class MemberController {
	...    
}
```



@RequestMapping이 붙은 클래스 안에 @RequestMapping을 붙여 계층화를 이룰 수도 있습니다.

```java
@Controller
@RequestMapping(&quot;/member&quot;)
public class MemberController {
    @RequestMapping(&quot;/memJoin&quot;)
    public String memJoin() {}
}
```



## 요청 파라미터 처리

사용자가 전달하는 HTTP 전송 정보를 Controller에서 사용하는 방법은 여러가지가 있습니다.



예시)

```html
&lt;input type=&quot;text&quot; name=&quot;memID&quot;&gt;
&lt;input type=&quot;password&quot; name=&quot;memPW&quot;&gt;
```

위과 같은 HTML 파일의 input 정보를 사용자가 전달한다고 가정하면 다음과 같은 방법으로 Controller에서 이를 활용할 수 있습니다.



### 방법1) `HttpServletRequest`

1. 먼저 **HttpServletRequest Class**를 이용해 &lt;u&gt;Request 정보 전체를 파라미터로 받습니다.&lt;/u&gt;

```java
@RequestMapping(value=&quot;/memLogin&quot;, method=RequestMethod.POST)
public String memLogin(Model model, HttpServletRequest request) {
    ...
}
```

2. 그리고 HttpServletRequest 클래스로 받은 파라미터 객체에서 &lt;u&gt;Getter를 이용해 개별 정보를 출력합니다.&lt;/u&gt;

```java
@RequestMapping(value=&quot;/memLogin&quot;, method=RequestMethod.POST)
public String memLogin(Model model, HttpServletRequest request) {
    
    String memID = request.getParameter(&quot;memID&quot;);
    String memPW = request.getParameter(&quot;memPW&quot;);
    
}
```



### 방법2) `@RequestParam`

1. 또 다른 방법은 **@RequestParam 어노테이션**을 객체에 붙여 &lt;u&gt;Request 정보를 개별적인 파라미터로 받는 것&lt;/u&gt;이 있습니다.

```java
@RequestMapping(value=&quot;/memLogin&quot;, method=RequestMethod.POST)
public String memLogin(Model model, @RequestParam(&quot;memID&quot;) String memID, @RequestParam(&quot;memPW&quot;) String memPW) {
    ...
}
```

이 경우 Getter를 이용하지 않지만 메소드의 파라미터 정의 부분이 길어져 보기 지저분하다는 단점이 있습니다.



&gt;  @RequestParam(..., **require=false**) : 값이 넘어오지 않아도 Exception 발생 X

&gt;  @RequestParam(..., **defaultValue=&quot;&quot;**) : 값이 넘어오지 않았을 때 들어가는 값



### 방법3) `커맨드 객체` * 가장 많이 사용하는 방법

마지막은 가장 많이 사용하는 방법인 커맨드 객체를 활용하는 방법입니다.

1. 먼저 데이터를 받기 위한 &lt;u&gt;전용 Class&lt;/u&gt;를 따로 만들어 줍니다.

```java
public class Member {
    
    private String memID;
    private String memPW;
    
    public String getMemID() {
        return memID;
    }
    public void setMemID(String memID) {
        this.memID = memID;
    }
    public String getMemPW() {
        return memPW;
    }
    public void setMemID(String memPW) {
        this.memPW = memPW;
    }
    
}
```

(ex. Member.java 안에 만든 Member 클래스)

2. &lt;u&gt;Request 정보를 새롭게 만든 객체에 저장&lt;/u&gt;, 이후 &lt;u&gt;Class 내 직접 만든 Getter를 이용해 Data를 출력합니다.&lt;/u&gt;

```java
@RequestMapping(value=&quot;/memLogin&quot;, method=RequestMethod.POST)
public String memLogin(Member member) {
    ...
}
```

(ex. MemberController.java)



#### `@ModelAttribute`

`@ModelAttribute` 어노테이션은 파라미터인 파라미터인 &lt;u&gt;커맨드 객체에&lt;/u&gt; 붙어 **커맨드 객체의 이름**을 설정합니다.

이후 **View(JSP)**에서 커맨드 객체를 참조할 때 변경된 이름을 통해 객체의 값을 불러올 수 있습니다.



[@ModelAttribute 미사용]

```java
public String test1(MyModel mym) {}
```

```jsp
${mym.id}
```

- mym 객체를 View에서 불러올 때, mym 객체의 이름을 그대로 사용



[@ModelAttribute 사용]

```java
public String test2(@ModelAttribute(&quot;mymy&quot;) MyModel mym) {}
```

```jsp
${mymy.id}
```

- mymy라는 이름으로 mym 객체를 View에서 불러옴



#### `@RequestBody`, `@RequestParam`

- **@ModelAttribute** : HTTP 정보를 Model(객체)에 주입합니다.
  - &#x27;생성자&#x27;나 &#x27;Setter&#x27;를 통해 주입 (만약 생성자나 Setter가 없으면 Mapping 되지 않습니다)
  - HTTP Parameter의 타입 - 객체의 타입 검증 과정이 존재 (두 타입이 일치하지 않으면 BindException이 발생합니다)
- **@RequestBody** : JSON 형태로 오는 HTTP Body의 정보를 Java의 객체로 변환시킵니다.
- **@RequestParam** : &lt;u&gt;1개의 HTTP 요청 파라미터&lt;/u&gt;를 받습니다.
  - 기본적으로 **required=true**로 설정 (해당 파라미터가 없으면 400 Error를 반환합니다)



## 데이터 타입

&gt; 커맨드 객체의 데이터 타입

```html
&lt;input type=&quot;text&quot; name=&quot;memId&quot;&gt;
&lt;input type=&quot;password&quot; name=&quot;memPw&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memAge&quot; size=&quot;4&quot; value=&quot;0&quot;&gt;
```

이런 input data를 받았을 때,

```java
public class Member {
    private String memId;
    private String memPw;
    private int memAge;
}
```

당연하게도 커맨드 객체에서 원하는 데이터 타입으로 저장할 수 있습니다.



만약 input data 여러 개를 하나의 변수에 저장해야 한다면 List 타입에 저장을 하면 됩니다.

```html
PHONE1 : 
&lt;input type=&quot;text&quot; name=&quot;memPhones[0].memPhone1&quot; size=&quot;5&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memPhones[0].memPhone2&quot; size=&quot;5&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memPhones[0].memPhone3&quot; size=&quot;5&quot;&gt;

PHONE2 : 
&lt;input type=&quot;text&quot; name=&quot;memPhones[1].memPhone1&quot; size=&quot;5&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memPhones[1].memPhone2&quot; size=&quot;5&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memPhones[1].memPhone3&quot; size=&quot;5&quot;&gt;
```

```java
private List&lt;MemPhone&gt; memPhones;
```



- **memPhone1** + **memPhone2** + **memPhone3** =&gt; `memPhone` 클래스
- **memPhone** + **memPhone** =&gt; `List&lt;memPhone&gt; memPhones` ; memPhone이 모인 List, memPhones



## Model &amp; ModelAndView

`Model`과 `ModelAndView` 모두 &lt;u&gt;View에 데이터를 전달&lt;/u&gt;하기 위해 **Controller에서 사용되는 객체**입니다.

차이 점은 `Model`은 **데이터만** 전달하지만, `ModelAndView`는 **데이터와 뷰의 이름**을 함께 전달한다는 것입니다.



비교를 위한 코드입니다.

(**memModifyOk.jsp**라는 View에서 **${memBef.memId}**, **${memAft.memId}**라는 이름으로 데이터를 사용하기 위한 `Model`과 `ModelAndView` 코드)

```java
// Model
@RequestMapping(value = &quot;/memModify&quot;, method = RequestMethod.POST)
public String memModify(Model model, Member member) {
    Member[] members = service.memberModify(member);
    
    model.addAttribute(&quot;memBef&quot;, members[0]);
    model.addAttribute(&quot;memAft&quot;, members[1]);
    
    return &quot;memModifyOk&quot;;
}
```

```java
// ModelAndView
@RequestMapping(value = &quot;/memModify&quot;, method = RequestMethod.POST)
public ModelAndView memModify(Member member) {
	Member[] members = service.memberModify(member);
    
    ModelAndView mav = new ModelAndView();
    mav.addObject(&quot;memBef&quot;, members[0]);
    mav.addObject(&quot;memAft&quot;, members[1]);
    
    mav.setViewName(&quot;memModifyOk&quot;);
    
    return mav;
}
```





## 출처

인프런 - 자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌

http://wonwoo.ml/index.php/post/2308

https://mangkyu.tistory.com/72
"/><meta property="og:type" content="website"/><meta property="og:title" content="[Spring] Controller 객체"/><meta property="og:description" content="# [Spring] Controller 객체

오늘은 비즈니스 로직이 들어가 있는 Controller 객체에 대해 알아보겠습니다.



## URL 매핑 - `@RequestMapping`

사용자가 요청을 보내면 &lt;u&gt;(1) Dispatcher Servlet&lt;/u&gt;이 &lt;u&gt;(2) HandlerMapping&lt;/u&gt; 을 통해 적합한 Controller를 찾습니다. 

HandlerMapping의 방법엔 여러가지가 있는데 `@RequestMapping`은 그 중 하나인 **RequestMappingHandlerMapping** 방법에서 적합한 Controller 객체를 찾는 어노테이션입니다.

```java
@Controller
@RequestMapping(&quot;/member&quot;)
public class MemberController {
	...    
}
```



@RequestMapping이 붙은 클래스 안에 @RequestMapping을 붙여 계층화를 이룰 수도 있습니다.

```java
@Controller
@RequestMapping(&quot;/member&quot;)
public class MemberController {
    @RequestMapping(&quot;/memJoin&quot;)
    public String memJoin() {}
}
```



## 요청 파라미터 처리

사용자가 전달하는 HTTP 전송 정보를 Controller에서 사용하는 방법은 여러가지가 있습니다.



예시)

```html
&lt;input type=&quot;text&quot; name=&quot;memID&quot;&gt;
&lt;input type=&quot;password&quot; name=&quot;memPW&quot;&gt;
```

위과 같은 HTML 파일의 input 정보를 사용자가 전달한다고 가정하면 다음과 같은 방법으로 Controller에서 이를 활용할 수 있습니다.



### 방법1) `HttpServletRequest`

1. 먼저 **HttpServletRequest Class**를 이용해 &lt;u&gt;Request 정보 전체를 파라미터로 받습니다.&lt;/u&gt;

```java
@RequestMapping(value=&quot;/memLogin&quot;, method=RequestMethod.POST)
public String memLogin(Model model, HttpServletRequest request) {
    ...
}
```

2. 그리고 HttpServletRequest 클래스로 받은 파라미터 객체에서 &lt;u&gt;Getter를 이용해 개별 정보를 출력합니다.&lt;/u&gt;

```java
@RequestMapping(value=&quot;/memLogin&quot;, method=RequestMethod.POST)
public String memLogin(Model model, HttpServletRequest request) {
    
    String memID = request.getParameter(&quot;memID&quot;);
    String memPW = request.getParameter(&quot;memPW&quot;);
    
}
```



### 방법2) `@RequestParam`

1. 또 다른 방법은 **@RequestParam 어노테이션**을 객체에 붙여 &lt;u&gt;Request 정보를 개별적인 파라미터로 받는 것&lt;/u&gt;이 있습니다.

```java
@RequestMapping(value=&quot;/memLogin&quot;, method=RequestMethod.POST)
public String memLogin(Model model, @RequestParam(&quot;memID&quot;) String memID, @RequestParam(&quot;memPW&quot;) String memPW) {
    ...
}
```

이 경우 Getter를 이용하지 않지만 메소드의 파라미터 정의 부분이 길어져 보기 지저분하다는 단점이 있습니다.



&gt;  @RequestParam(..., **require=false**) : 값이 넘어오지 않아도 Exception 발생 X

&gt;  @RequestParam(..., **defaultValue=&quot;&quot;**) : 값이 넘어오지 않았을 때 들어가는 값



### 방법3) `커맨드 객체` * 가장 많이 사용하는 방법

마지막은 가장 많이 사용하는 방법인 커맨드 객체를 활용하는 방법입니다.

1. 먼저 데이터를 받기 위한 &lt;u&gt;전용 Class&lt;/u&gt;를 따로 만들어 줍니다.

```java
public class Member {
    
    private String memID;
    private String memPW;
    
    public String getMemID() {
        return memID;
    }
    public void setMemID(String memID) {
        this.memID = memID;
    }
    public String getMemPW() {
        return memPW;
    }
    public void setMemID(String memPW) {
        this.memPW = memPW;
    }
    
}
```

(ex. Member.java 안에 만든 Member 클래스)

2. &lt;u&gt;Request 정보를 새롭게 만든 객체에 저장&lt;/u&gt;, 이후 &lt;u&gt;Class 내 직접 만든 Getter를 이용해 Data를 출력합니다.&lt;/u&gt;

```java
@RequestMapping(value=&quot;/memLogin&quot;, method=RequestMethod.POST)
public String memLogin(Member member) {
    ...
}
```

(ex. MemberController.java)



#### `@ModelAttribute`

`@ModelAttribute` 어노테이션은 파라미터인 파라미터인 &lt;u&gt;커맨드 객체에&lt;/u&gt; 붙어 **커맨드 객체의 이름**을 설정합니다.

이후 **View(JSP)**에서 커맨드 객체를 참조할 때 변경된 이름을 통해 객체의 값을 불러올 수 있습니다.



[@ModelAttribute 미사용]

```java
public String test1(MyModel mym) {}
```

```jsp
${mym.id}
```

- mym 객체를 View에서 불러올 때, mym 객체의 이름을 그대로 사용



[@ModelAttribute 사용]

```java
public String test2(@ModelAttribute(&quot;mymy&quot;) MyModel mym) {}
```

```jsp
${mymy.id}
```

- mymy라는 이름으로 mym 객체를 View에서 불러옴



#### `@RequestBody`, `@RequestParam`

- **@ModelAttribute** : HTTP 정보를 Model(객체)에 주입합니다.
  - &#x27;생성자&#x27;나 &#x27;Setter&#x27;를 통해 주입 (만약 생성자나 Setter가 없으면 Mapping 되지 않습니다)
  - HTTP Parameter의 타입 - 객체의 타입 검증 과정이 존재 (두 타입이 일치하지 않으면 BindException이 발생합니다)
- **@RequestBody** : JSON 형태로 오는 HTTP Body의 정보를 Java의 객체로 변환시킵니다.
- **@RequestParam** : &lt;u&gt;1개의 HTTP 요청 파라미터&lt;/u&gt;를 받습니다.
  - 기본적으로 **required=true**로 설정 (해당 파라미터가 없으면 400 Error를 반환합니다)



## 데이터 타입

&gt; 커맨드 객체의 데이터 타입

```html
&lt;input type=&quot;text&quot; name=&quot;memId&quot;&gt;
&lt;input type=&quot;password&quot; name=&quot;memPw&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memAge&quot; size=&quot;4&quot; value=&quot;0&quot;&gt;
```

이런 input data를 받았을 때,

```java
public class Member {
    private String memId;
    private String memPw;
    private int memAge;
}
```

당연하게도 커맨드 객체에서 원하는 데이터 타입으로 저장할 수 있습니다.



만약 input data 여러 개를 하나의 변수에 저장해야 한다면 List 타입에 저장을 하면 됩니다.

```html
PHONE1 : 
&lt;input type=&quot;text&quot; name=&quot;memPhones[0].memPhone1&quot; size=&quot;5&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memPhones[0].memPhone2&quot; size=&quot;5&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memPhones[0].memPhone3&quot; size=&quot;5&quot;&gt;

PHONE2 : 
&lt;input type=&quot;text&quot; name=&quot;memPhones[1].memPhone1&quot; size=&quot;5&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memPhones[1].memPhone2&quot; size=&quot;5&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;memPhones[1].memPhone3&quot; size=&quot;5&quot;&gt;
```

```java
private List&lt;MemPhone&gt; memPhones;
```



- **memPhone1** + **memPhone2** + **memPhone3** =&gt; `memPhone` 클래스
- **memPhone** + **memPhone** =&gt; `List&lt;memPhone&gt; memPhones` ; memPhone이 모인 List, memPhones



## Model &amp; ModelAndView

`Model`과 `ModelAndView` 모두 &lt;u&gt;View에 데이터를 전달&lt;/u&gt;하기 위해 **Controller에서 사용되는 객체**입니다.

차이 점은 `Model`은 **데이터만** 전달하지만, `ModelAndView`는 **데이터와 뷰의 이름**을 함께 전달한다는 것입니다.



비교를 위한 코드입니다.

(**memModifyOk.jsp**라는 View에서 **${memBef.memId}**, **${memAft.memId}**라는 이름으로 데이터를 사용하기 위한 `Model`과 `ModelAndView` 코드)

```java
// Model
@RequestMapping(value = &quot;/memModify&quot;, method = RequestMethod.POST)
public String memModify(Model model, Member member) {
    Member[] members = service.memberModify(member);
    
    model.addAttribute(&quot;memBef&quot;, members[0]);
    model.addAttribute(&quot;memAft&quot;, members[1]);
    
    return &quot;memModifyOk&quot;;
}
```

```java
// ModelAndView
@RequestMapping(value = &quot;/memModify&quot;, method = RequestMethod.POST)
public ModelAndView memModify(Member member) {
	Member[] members = service.memberModify(member);
    
    ModelAndView mav = new ModelAndView();
    mav.addObject(&quot;memBef&quot;, members[0]);
    mav.addObject(&quot;memAft&quot;, members[1]);
    
    mav.setViewName(&quot;memModifyOk&quot;);
    
    return mav;
}
```





## 출처

인프런 - 자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌

http://wonwoo.ml/index.php/post/2308

https://mangkyu.tistory.com/72
"/><meta property="og:site_name" content="웅&#x27;s 블로그"/><link rel="icon" href="/myLogo_transp.png"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a1ca12cc1e4f36e64c14.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8d2cfc0c48a9fc169b11.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-90a60b87fd0d5fc150f2.js" defer=""></script><script src="/_next/static/chunks/framework-0441fae7fd130f37dee1.js" defer=""></script><script src="/_next/static/chunks/main-d1e3ce7bd5cd46c1581b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-27d5fdc1d85004dc6cc5.js" defer=""></script><script src="/_next/static/chunks/485-1121db7a55400d486874.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5BarticleCategory%5D/%5BarticleId%5D-9ceb51083ce229176f1f.js" defer=""></script><script src="/_next/static/t1ga9om9q0UCF0Wlijaam/_buildManifest.js" defer=""></script><script src="/_next/static/t1ga9om9q0UCF0Wlijaam/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App"><div class="App__Content"><div class="Header_Header__1J9sN"><div class="Header_Header__styling__U361E"><img src="/myLogo_transp.png" alt="logo"/></div><a class="Header_Header__word__hqgKV" href="/">Home</a><a class="Header_Header__word__hqgKV" href="/profile">Profile</a><a class="Header_Header__word__hqgKV" href="/articles">Articles</a><a class="Header_Header__word__hqgKV" href="/archives">Archives</a><div class="Header_Header__styling_Reverse__2G1sc"></div></div><div><main><div class="globalStyles_loader__29zgS"><span>Loading...</span></div></main></div></div><div class="Footer_Footer__16BK3"><div class="Footer_Footer__github__3FRw-">Github : <a href="https://github.com/ParkJeongwoong">ParkJeongwoong</a></div><div class="Footer_Footer__email__gbWyz">Contact : <span>dvlprjw@gmail.com</span></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdown":"# [Spring] Controller 객체\r\n\r\n오늘은 비즈니스 로직이 들어가 있는 Controller 객체에 대해 알아보겠습니다.\r\n\r\n\r\n\r\n## URL 매핑 - `@RequestMapping`\r\n\r\n사용자가 요청을 보내면 \u003cu\u003e(1) Dispatcher Servlet\u003c/u\u003e이 \u003cu\u003e(2) HandlerMapping\u003c/u\u003e 을 통해 적합한 Controller를 찾습니다. \r\n\r\nHandlerMapping의 방법엔 여러가지가 있는데 `@RequestMapping`은 그 중 하나인 **RequestMappingHandlerMapping** 방법에서 적합한 Controller 객체를 찾는 어노테이션입니다.\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/member\")\r\npublic class MemberController {\r\n\t...    \r\n}\r\n```\r\n\r\n\r\n\r\n@RequestMapping이 붙은 클래스 안에 @RequestMapping을 붙여 계층화를 이룰 수도 있습니다.\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/member\")\r\npublic class MemberController {\r\n    @RequestMapping(\"/memJoin\")\r\n    public String memJoin() {}\r\n}\r\n```\r\n\r\n\r\n\r\n## 요청 파라미터 처리\r\n\r\n사용자가 전달하는 HTTP 전송 정보를 Controller에서 사용하는 방법은 여러가지가 있습니다.\r\n\r\n\r\n\r\n예시)\r\n\r\n```html\r\n\u003cinput type=\"text\" name=\"memID\"\u003e\r\n\u003cinput type=\"password\" name=\"memPW\"\u003e\r\n```\r\n\r\n위과 같은 HTML 파일의 input 정보를 사용자가 전달한다고 가정하면 다음과 같은 방법으로 Controller에서 이를 활용할 수 있습니다.\r\n\r\n\r\n\r\n### 방법1) `HttpServletRequest`\r\n\r\n1. 먼저 **HttpServletRequest Class**를 이용해 \u003cu\u003eRequest 정보 전체를 파라미터로 받습니다.\u003c/u\u003e\r\n\r\n```java\r\n@RequestMapping(value=\"/memLogin\", method=RequestMethod.POST)\r\npublic String memLogin(Model model, HttpServletRequest request) {\r\n    ...\r\n}\r\n```\r\n\r\n2. 그리고 HttpServletRequest 클래스로 받은 파라미터 객체에서 \u003cu\u003eGetter를 이용해 개별 정보를 출력합니다.\u003c/u\u003e\r\n\r\n```java\r\n@RequestMapping(value=\"/memLogin\", method=RequestMethod.POST)\r\npublic String memLogin(Model model, HttpServletRequest request) {\r\n    \r\n    String memID = request.getParameter(\"memID\");\r\n    String memPW = request.getParameter(\"memPW\");\r\n    \r\n}\r\n```\r\n\r\n\r\n\r\n### 방법2) `@RequestParam`\r\n\r\n1. 또 다른 방법은 **@RequestParam 어노테이션**을 객체에 붙여 \u003cu\u003eRequest 정보를 개별적인 파라미터로 받는 것\u003c/u\u003e이 있습니다.\r\n\r\n```java\r\n@RequestMapping(value=\"/memLogin\", method=RequestMethod.POST)\r\npublic String memLogin(Model model, @RequestParam(\"memID\") String memID, @RequestParam(\"memPW\") String memPW) {\r\n    ...\r\n}\r\n```\r\n\r\n이 경우 Getter를 이용하지 않지만 메소드의 파라미터 정의 부분이 길어져 보기 지저분하다는 단점이 있습니다.\r\n\r\n\r\n\r\n\u003e  @RequestParam(..., **require=false**) : 값이 넘어오지 않아도 Exception 발생 X\r\n\r\n\u003e  @RequestParam(..., **defaultValue=\"\"**) : 값이 넘어오지 않았을 때 들어가는 값\r\n\r\n\r\n\r\n### 방법3) `커맨드 객체` * 가장 많이 사용하는 방법\r\n\r\n마지막은 가장 많이 사용하는 방법인 커맨드 객체를 활용하는 방법입니다.\r\n\r\n1. 먼저 데이터를 받기 위한 \u003cu\u003e전용 Class\u003c/u\u003e를 따로 만들어 줍니다.\r\n\r\n```java\r\npublic class Member {\r\n    \r\n    private String memID;\r\n    private String memPW;\r\n    \r\n    public String getMemID() {\r\n        return memID;\r\n    }\r\n    public void setMemID(String memID) {\r\n        this.memID = memID;\r\n    }\r\n    public String getMemPW() {\r\n        return memPW;\r\n    }\r\n    public void setMemID(String memPW) {\r\n        this.memPW = memPW;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n(ex. Member.java 안에 만든 Member 클래스)\r\n\r\n2. \u003cu\u003eRequest 정보를 새롭게 만든 객체에 저장\u003c/u\u003e, 이후 \u003cu\u003eClass 내 직접 만든 Getter를 이용해 Data를 출력합니다.\u003c/u\u003e\r\n\r\n```java\r\n@RequestMapping(value=\"/memLogin\", method=RequestMethod.POST)\r\npublic String memLogin(Member member) {\r\n    ...\r\n}\r\n```\r\n\r\n(ex. MemberController.java)\r\n\r\n\r\n\r\n#### `@ModelAttribute`\r\n\r\n`@ModelAttribute` 어노테이션은 파라미터인 파라미터인 \u003cu\u003e커맨드 객체에\u003c/u\u003e 붙어 **커맨드 객체의 이름**을 설정합니다.\r\n\r\n이후 **View(JSP)**에서 커맨드 객체를 참조할 때 변경된 이름을 통해 객체의 값을 불러올 수 있습니다.\r\n\r\n\r\n\r\n[@ModelAttribute 미사용]\r\n\r\n```java\r\npublic String test1(MyModel mym) {}\r\n```\r\n\r\n```jsp\r\n${mym.id}\r\n```\r\n\r\n- mym 객체를 View에서 불러올 때, mym 객체의 이름을 그대로 사용\r\n\r\n\r\n\r\n[@ModelAttribute 사용]\r\n\r\n```java\r\npublic String test2(@ModelAttribute(\"mymy\") MyModel mym) {}\r\n```\r\n\r\n```jsp\r\n${mymy.id}\r\n```\r\n\r\n- mymy라는 이름으로 mym 객체를 View에서 불러옴\r\n\r\n\r\n\r\n#### `@RequestBody`, `@RequestParam`\r\n\r\n- **@ModelAttribute** : HTTP 정보를 Model(객체)에 주입합니다.\r\n  - '생성자'나 'Setter'를 통해 주입 (만약 생성자나 Setter가 없으면 Mapping 되지 않습니다)\r\n  - HTTP Parameter의 타입 - 객체의 타입 검증 과정이 존재 (두 타입이 일치하지 않으면 BindException이 발생합니다)\r\n- **@RequestBody** : JSON 형태로 오는 HTTP Body의 정보를 Java의 객체로 변환시킵니다.\r\n- **@RequestParam** : \u003cu\u003e1개의 HTTP 요청 파라미터\u003c/u\u003e를 받습니다.\r\n  - 기본적으로 **required=true**로 설정 (해당 파라미터가 없으면 400 Error를 반환합니다)\r\n\r\n\r\n\r\n## 데이터 타입\r\n\r\n\u003e 커맨드 객체의 데이터 타입\r\n\r\n```html\r\n\u003cinput type=\"text\" name=\"memId\"\u003e\r\n\u003cinput type=\"password\" name=\"memPw\"\u003e\r\n\u003cinput type=\"text\" name=\"memAge\" size=\"4\" value=\"0\"\u003e\r\n```\r\n\r\n이런 input data를 받았을 때,\r\n\r\n```java\r\npublic class Member {\r\n    private String memId;\r\n    private String memPw;\r\n    private int memAge;\r\n}\r\n```\r\n\r\n당연하게도 커맨드 객체에서 원하는 데이터 타입으로 저장할 수 있습니다.\r\n\r\n\r\n\r\n만약 input data 여러 개를 하나의 변수에 저장해야 한다면 List 타입에 저장을 하면 됩니다.\r\n\r\n```html\r\nPHONE1 : \r\n\u003cinput type=\"text\" name=\"memPhones[0].memPhone1\" size=\"5\"\u003e\r\n\u003cinput type=\"text\" name=\"memPhones[0].memPhone2\" size=\"5\"\u003e\r\n\u003cinput type=\"text\" name=\"memPhones[0].memPhone3\" size=\"5\"\u003e\r\n\r\nPHONE2 : \r\n\u003cinput type=\"text\" name=\"memPhones[1].memPhone1\" size=\"5\"\u003e\r\n\u003cinput type=\"text\" name=\"memPhones[1].memPhone2\" size=\"5\"\u003e\r\n\u003cinput type=\"text\" name=\"memPhones[1].memPhone3\" size=\"5\"\u003e\r\n```\r\n\r\n```java\r\nprivate List\u003cMemPhone\u003e memPhones;\r\n```\r\n\r\n\r\n\r\n- **memPhone1** + **memPhone2** + **memPhone3** =\u003e `memPhone` 클래스\r\n- **memPhone** + **memPhone** =\u003e `List\u003cmemPhone\u003e memPhones` ; memPhone이 모인 List, memPhones\r\n\r\n\r\n\r\n## Model \u0026 ModelAndView\r\n\r\n`Model`과 `ModelAndView` 모두 \u003cu\u003eView에 데이터를 전달\u003c/u\u003e하기 위해 **Controller에서 사용되는 객체**입니다.\r\n\r\n차이 점은 `Model`은 **데이터만** 전달하지만, `ModelAndView`는 **데이터와 뷰의 이름**을 함께 전달한다는 것입니다.\r\n\r\n\r\n\r\n비교를 위한 코드입니다.\r\n\r\n(**memModifyOk.jsp**라는 View에서 **${memBef.memId}**, **${memAft.memId}**라는 이름으로 데이터를 사용하기 위한 `Model`과 `ModelAndView` 코드)\r\n\r\n```java\r\n// Model\r\n@RequestMapping(value = \"/memModify\", method = RequestMethod.POST)\r\npublic String memModify(Model model, Member member) {\r\n    Member[] members = service.memberModify(member);\r\n    \r\n    model.addAttribute(\"memBef\", members[0]);\r\n    model.addAttribute(\"memAft\", members[1]);\r\n    \r\n    return \"memModifyOk\";\r\n}\r\n```\r\n\r\n```java\r\n// ModelAndView\r\n@RequestMapping(value = \"/memModify\", method = RequestMethod.POST)\r\npublic ModelAndView memModify(Member member) {\r\n\tMember[] members = service.memberModify(member);\r\n    \r\n    ModelAndView mav = new ModelAndView();\r\n    mav.addObject(\"memBef\", members[0]);\r\n    mav.addObject(\"memAft\", members[1]);\r\n    \r\n    mav.setViewName(\"memModifyOk\");\r\n    \r\n    return mav;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 출처\r\n\r\n인프런 - 자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌\r\n\r\nhttp://wonwoo.ml/index.php/post/2308\r\n\r\nhttps://mangkyu.tistory.com/72\r\n","documentTitle":"[Spring] Controller 객체"},"__N_SSG":true},"page":"/articles/[articleCategory]/[articleId]","query":{"articleCategory":"Web","articleId":"9"},"buildId":"t1ga9om9q0UCF0Wlijaam","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>